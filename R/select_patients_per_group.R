# WARNING - Generated by {fusen} from dev/sample_selections.Rmd: do not edit by hand # nolint: line_length_linter.

#' Select patients per group
#' For sample selections often this is based on patient groups and required number of patients maybe be different per patient group. This function helps with this selection 
#' @param df A data.frame with clinical data and number of aliquots per patient column 
#' @param patient_group_col The column name with patient characterization 
#' @param patient_groups A vector of patient group. This names should be categories in patient_group_col
#' @param number_per_group A vector same length indicating how many patient to select per group 
#' @param sort_cols column(s) names that should be used to sort your data frame. We prefer to select patients with higher of aliquots 
#' @param shuffle logical. If TRUE, the data will be shuffled before selection. Default is FALSE
#' @param number_of_aliquots_col The column name with number of aliquots per patient. Default is "number_of_aliquots"
#' @param ... Additional arguments to be passed to  select_and_shuffle_dt function
#' @importFrom data.table setDT rbindlist setorderv setcolorder
#' @return data.table 
#' 
#' @export
#' @examples
#'
#' library(data.table)
#' library(dplyr)
#' data("tb_data", package = "findBiobankR")
#' data("tb_specimen_df", package = "findBiobankR")
#'
#' # required clinical cols
#' clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 
#'
#' clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
#'                                      specimen_df = tb_specimen_df, 
#'                                      join_by_col = "ppid",
#'                                      specimen_col ="specimen_type" ,
#'                                      clinical_vars = clinical_cols ,
#'                                      specimen_label_col = "specimen_label",
#'                                      os_aliquot_names = c("Serum", "Plasma")
#' )
#'
#'
#' ## select 2 patients per group 
#' patient_groups  <- c("TB, Neg", "TB, Pos")
#' number_per_group  <- c(2, 2)
#' sort_cols = "NP_aliqN_serum"
#' clin_specs_2 <- select_patients_per_group(df = clin_specs, 
#'                                           patient_group_col = "tb_group",
#'                                           patient_groups = patient_groups,
#'                                           number_per_group = number_per_group,
#'                                           sort_cols = sort_cols)
#'
#'

select_patients_per_group <- function(df, 
                                       patient_group_col,
                                       patient_groups, 
                                       number_per_group, 
                                      sort_cols, 
                                      number_of_aliquots_col = "number_of_aliquots", 
                                      shuffle = FALSE, ...) {
  # Check if number_per_group is a single value; if so, replicate it for all patient groups
  if (length(number_per_group) == 1) {
    number_per_group <- rep(number_per_group, length(patient_groups))
  }
  
  # Ensure number_per_group has the same length as patient_groups after replication
  if (length(number_per_group) != length(patient_groups)) {
    stop("The number_per_group vector must either be a single value or match the length of patient_groups.")
  }
  
  setDT(df)
  list_selected <- vector(mode = "list", length = length(patient_groups))
  
  for (i in seq_along(patient_groups)) {
    patient_grp <- patient_groups[i]
    no_i <- number_per_group[i]
    df1 <- df[get(patient_group_col) == patient_grp]
    
    # If the requested number exceeds available rows, show warning and select all rows
    if (nrow(df1) < no_i) {
      warning(glue::glue("Patient group {patient_grp} has only {nrow(df1)} participants, which is less than the requested {no_i}. Selecting all available participants."))
      no_i <- nrow(df1)
    }
    
    # Sort and shuffle if required
    setorderv(df1, cols = sort_cols, order = -1L)
    if (shuffle) {
      df1 <- select_and_shuffle_dt(df1, numeric_var = number_of_aliquots_col, ...)
    }
    
    # Select the required number of rows
    df1 <- df1[1:no_i]
    list_selected[[i]] <- df1
  }
  
  # Combine all selected rows into a single data.table
  df_final <- rbindlist(list_selected)
  df_final
}


# Define the function
move_columns <- function(df, cols_to_move, position = "last") {
  # Ensure df is a data.table
  setDT(df)
  
  # Get the current column names
  all_cols <- colnames(df)
  
  # Ensure the specified columns exist in the data
  cols_to_move <- intersect(cols_to_move, all_cols)
  
  # Remaining columns after removing the ones to move
  remaining_cols <- setdiff(all_cols, cols_to_move)
  
  # Reorder columns based on the specified position
  if (position == "first") {
    new_order <- c(cols_to_move, remaining_cols)
  } else {
    new_order <- c(remaining_cols, cols_to_move)
  }
  
  # Set the new column order
  setcolorder(df, new_order)
  
  return(df)
}


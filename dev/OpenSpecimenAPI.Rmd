---
title: "flat_my_fun.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# auth_os

```{r function-auth_os}
#' Authenticate to the OpenSpecimen API
#'
#' This function authenticates a user to the OpenSpecimen API using the provided
#' URL, username, and password.
#'
#' @param url The URL of the OpenSpecimen API.
#' @param username The username for authentication.
#' @param password The password for authentication.
#' @param domain_name The domain name (default is "openspecimen").
#'
#' @return A list with the URL and the authentication response which contains auth token and user details
#' @importFrom httr POST  add_headers content status_code
#' @note See additional information on this API on https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1116035/REST+APIs
#' @export
#' 
auth_os <- function(url ,
                    username,
                    password, 
                    domain_name = "openspecimen") {
  # Define the login request data as a JSON object
  sessions_url <- paste0(url, "/sessions")
  
  login <- list(
    loginName = username,
    password = password,
    domainName = domain_name
  )
  
  # Specify the content type as JSON in the header
  headers <- add_headers("Content-Type" = "application/json")
  
  # Make the POST request for authentication
  response <- POST(
    url = sessions_url,
    body = login,
    config = headers,
    encode = "json"
  )
  
  # Check the response status code
  status_code <- status_code(response)
  
  if (status_code %in% c(200, 201)) {
    # Authentication successful, return the response content
    auth_res = content(response, "parsed")
    
    cli::cli_alert_success("Authentication successful")
    
    return(list(url = url, auth_response = auth_res))
    
  } else {
    # Authentication failed, return an error message or handle it as needed
    error_message <- content(response, "text")
    error_message <- gsub("[^a-zA-Z0-9 ]", " ", error_message)
    error_message <- sub(".*\\bmessage\\s*(.*)", "\\1", error_message, ignore.case = TRUE)
    cli::cli_alert_danger(paste("Authentication failed with status code", status_code, ":", error_message))
  }
}

```

```{r example-auth_os, eval=FALSE}

# os_test_url <- Sys.getenv("OSTESTURL")
# os_test_username <- Sys.getenv("OSUSERNAME")
# os_test_password <- Sys.getenv("OSPASSWORDTEST")
# 
# auth_repo <- auth_os(url = os_test_url,
#                      username = os_test_username,
#                      password = os_test_password)

```


```{r tests-auth_os}
test_that("auth_os works", {
  expect_true(inherits(auth_os, "function")) 
})
```

# timestamp_to_date

```{r function-timestamp_to_date}
#' Convert Timestamp to Date
#'
#' This function can handle numeric or character inputs to convert timestamps to date time objects, 
#' and can also process specified timestamp columns in a data frame.
#' @param x The numeric timestamp, character timestamp string, or a data frame.
#' @param return_numeric (Optional) Return the converted date as numeric. Default is FALSE.
#' @return The converted date as a date time object or a data frame with converted columns.
#' @importFrom lubridate as_datetime
#' @importFrom data.table setDT
#' @export

convert_timestamp <- function(x, return_numeric = FALSE) {
  if (!is.numeric(x)) {
    warning("Input must be numeric.")
    return(x)
  }
  
  # Convert if x is in milliseconds
  x <- data.table::fifelse(nchar(as.character(x)) > 10, x / 1000, x)
  
  if (return_numeric) {
    return(x)
  } else {
    return(lubridate::as_datetime(x))
  }
}

#' Convert Timestamp to Date
#' This function converts a timestamp to a date time object
#' @param timestamp The timestamp to convert.
#' @param date_cols (Optional) The columns in the data frame to convert.
#' @param ... Additional arguments to be passed to convert_timestamp function
#' @seealso \code{\link{convert_timestamp}}
#' @return The converted date as a date time object.
#' @export

timestamp_to_date <- function(timestamp,
                              date_cols = NULL,
                                ...) {
  
  UseMethod("timestamp_to_date")
}


# Method for numeric class
#' Convert Timestamp to Date
#' This function converts a timestamp to a date time object
#' @param timestamp The timestamp to convert.
#' @param date_cols (Optional) The columns in the data frame to convert.
#' @param ... Additional arguments to be passed to the method.
#' @return The converted date as a date time object.
#' @export
timestamp_to_date.numeric <- function(timestamp,  
                                      date_cols = NULL, 
                                      ...) {
  
  return(convert_timestamp(timestamp, ...))
}


# Method for character class
#' Convert Timestamp to Date
#' This function converts a timestamp to a date time object
#' @param timestamp The timestamp to convert.
#' @param date_cols (Optional) The columns in the data frame to convert.
#' @param ... Additional arguments to be passed to the method.
#' @return The converted date as a date time object.
#' @export
timestamp_to_date.character <- function(timestamp,date_cols, ...) {
  
  has_special_characters <- function(input) {
    input <- input[!is.na(input)]
    any(grepl("[-/:]", input))
  }
  
  is_all_digits <- function(input) {
    input <- input[!is.na(input)]
    all(grepl("^\\d+$", input))
  }
  
  if (!has_special_characters(timestamp)) {
    timestamp <- as.numeric(timestamp)
    return(convert_timestamp(timestamp, ...))
    
  }else if(!is_all_digits(timestamp)){
    
    # Define the vector of formats
    formats <- c("ymd_HMS", "ymd_HM", "ymd_H", "ymd",
                 "dmy_HMS", "dmy_HM", "dmy_H", "dmy",
                 "mdy_HMS", "mdy_HM", "mdy_H", "mdy")
    
    timestamp <- lubridate::parse_date_time(timestamp,  formats) %>%
      as.numeric()
    
    return(convert_timestamp(timestamp, ...))
    
    
    
  } else {  #(is.character(timestamp) & any(sapply(timestamp, has_special_characters)))
    
    warning("Input timestamp is not numeric or contains special characters. Skipping conversion.")
    
    return(timestamp)
  }
  
  
}


#' Convert Timestamp Columns in a Data Frame to Date
#'
#' This method converts timestamp columns in a data frame to date columns.
#'
#' @param timestamp Data frame with timestamp columns.
#' @param date_cols Names of the timestamp columns to convert.
#' @param ... (Optional) Return the converted date as numeric. Default is FALSE.
#'
#' @return A modified data frame with converted timestamp columns.
#'
#' @export
timestamp_to_date.data.frame <- function(timestamp, date_cols = NULL, ...){
  
  
  if(is.null(date_cols)){
    
    nms <- names(timestamp)
    
    date_cols <- nms[grepl("date", nms, ignore.case = TRUE)]
  }
  
  data.table::setDT(timestamp)
  
  leng <- length(date_cols)
  if(leng != 0){
    
    timestamp[, (date_cols) := lapply(.SD, timestamp_to_date, ...), .SDcols = date_cols]
    #df[, (date_cols) := lapply(.SD, timestamp_to_date.character, return_numeric), .SDcols = date_cols]
  }
  
  return(timestamp)

  
  
}

```


```{r example-timestamp_to_date}

timestamps <- c("1625068800000", "1625068801000", "1625068802000")
converted_timestamps <- timestamp_to_date(timestamps)
converted_timestamps

timestamps_numeric <- c(1625068800000, 1625068801000, 1625068802000)
converted_timestamps_numeric <- timestamp_to_date(timestamps_numeric)
converted_timestamps_numeric
timestamps_with_specials <- c("1625068800000", "2021-07-01 00:00:00", "1625068800/1000")
timestamps_with_specials <- c("1625068800000", "2021-07-01 00:00:00", "1625068800/1000")
timestamps_with_specials
# Example 2: Convert timestamp columns in a data frame
df <- data.table::data.table(id = c(1, 2, 3),
                 event_date_num = c(1637892323000, 1637892423000, 1637892523000),
                 event_date_char = c("1637892323000", "1637892423000", "1637892523000")
                 )


df = timestamp_to_date(df, return_numeric = FALSE)

df


date_time_strings <- c(
  "2017-03-22 12:34:56", # ymd_HMS
  "2017-03-22 12:34",    # ymd_HM
  "2017-03-22 12",       # ymd_H
  "2017-03-22",          # ymd
  "22-03-2017 12:34:56", # dmy_HMS
  "22-03-2017 12:34",    # dmy_HM
  "22-03-2017 12",       # dmy_H
  "22-03-2017",          # dmy
  "03-22-2017 12:34:56", # mdy_HMS
  "03-22-2017 12:34",    # mdy_HM
  "03-22-2017 12",       # mdy_H
  "03-22-2017"           # mdy
)

timestamp_to_date(date_time_strings)


```



```{r tests-timestamp_to_date}
test_that("timestamp_to_date works", {
  expect_true(inherits(timestamp_to_date, "function")) 
})
```

# parse_os_response

```{r function-parse_os_response}
#' OpenSpecimen API Request Response Handler
#'
#' This function handles the response from an OpenSpecimen API request, checks the status code,
#' and returns the parsed response content or handles errors as needed.
#'
#' @param response The response object from the OpenSpecimen API request.
#' @param parse_data_function The function used to parse the response data
#' @param skip_date_convertion Skip date conversion
#' @param ... Additional arguments to be passed to timestamp_to_date
#' @return Parsed content from the API response.
#'
#' @importFrom httr status_code content
#'
#' @export
parse_os_response <- function(response, parse_data_function, skip_date_convertion = FALSE, ...) {
  
  
  
  status_code <- status_code(response)
  
  if (status_code == 200) {
    # Query successful, return the parsed response content
    parse_data_function <- match.fun(parse_data_function)
    #cli::cli_alert_success("Query successful")
    df = parse_data_function(response)
    
    # if inherits data.frame apply timestamp_to_date
    
    if(inherits(df, "data.frame") & !skip_date_convertion){
      
      
     df =  timestamp_to_date(df, ...)
     
    }
    
    return(df)
    
  } else {
    # Query failed, return an error message or handle it as needed
    error_message <- content(response, "text")
    error_message <- gsub("[^a-zA-Z0-9 ]", " ", error_message)
    error_message <- sub(".*\\bmessage\\s*(.*)", "\\1", error_message, ignore.case = TRUE)
    stop(paste("Query failed with status code", status_code, ":", error_message))
    
  }
  
  
}

```


```{r example-parse_os_response}
#parse_os_response()
```


```{r tests-parse_os_response}
test_that("parse_os_response works", {
  expect_true(inherits(parse_os_response, "function")) 
})
```

# parse_data

```{r function-parse_data}
#' Parse Response Data
#'
#' This function parses the response data obtained from the OpenSpecimen API and
#' organizes it into a data frame.
#'
#' @param response The response data to be parsed.
#'
#' @return A data frame containing the parsed data.
#'
#' @importFrom httr content
#'
#'
#' @note Make sure to provide an HTTP response with the appropriate structure for parsing.
#'
#' @export
parse_data <- function(response) {
  
  # Parse the content from the response
  parsed_content_request <- content(response, as = "parsed")
  
  # Extract column names from the parsed content
  col_nms <- parsed_content_request$columnLabels %>% unlist()
  
  # Clean and format column names
  col_nms <- gsub("#", "", col_nms) %>% findBiobankR::make_clean_os_names()
  
  # Extract rows from the parsed content
  myrows <- parsed_content_request$rows
  n_rows <- length(myrows)
  # Create a data frame from the rows
  if(n_rows != 0 ) {
    
    df <- lapply(myrows, function(x) {
      rbind(x)
    }) %>%
      data.table::rbindlist()
    
    if(ncol(df) > 0){
      
      names(df) <- col_nms
    }
    
  } else {
    
    df <- NULL
  }
  
  
  return(df)
  
}

```

```{r example-parse_data}
#parse_data()
```

```{r tests-parse_data}
test_that("parse_data works", {
  expect_true(inherits(parse_data, "function")) 
})
```

# get_os_query

```{r function-get_os_query}
#' Execute a Saved Query
#'
#' This function executes a saved query in the OpenSpecimen API using the provided
#' authentication response and query ID. You can specify the parameters for the query
#' such as driving form, wide row mode, start position, and maximum results.
#'
#' @param auth_response The authentication response obtained from `auth_os`.
#' @param query_id The ID of the saved query to execute.
#' @param driving_form The driving form for the query (default is "Specimen").
#' @param wide_row_mode The wide row mode for the query (default is "OFF").
#' @param start_at The starting position for the query (optional).
#' @param max_results The maximum number of results to retrieve (optional).
#'
#' @return A data frame containing the results of the saved query.
#'
#' @importFrom httr POST add_headers status_code content
#' @note See additional information on this API on https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/104529939/Query
#' 
#' @export
get_os_query <- function(auth_response,
                         query_id,
                         driving_form = c("Specimen", "Participant"),
                         wide_row_mode = c("OFF", "DEEP", "SHALLOW"),
                         start_at = NULL,
                         max_results = NULL) {
  # Match the driving_form argument to one of the allowed values
  driving_form <- match.arg(driving_form)
  # Match the wide_row_mode argument to one of the allowed values
  wide_row_mode <- match.arg(wide_row_mode)
  # Extract the authentication token from the response
  auth_token <- auth_response$auth_response$token
  url <- auth_response$url
  # Define the query request data
  query_request <- list(
    drivingForm = driving_form,
    wideRowMode = wide_row_mode,
    startAt = start_at,
    maxResults = max_results
  )
  
  # Specify the content type as JSON in the header
  headers <- add_headers(
    "Content-Type" = "application/json",
    "X-OS-API-TOKEN" = auth_token
  )
  
  # Make the POST request for the query
  response <- POST(
    url = paste0(url, "/query/", query_id),
    body = query_request,
    config = headers,
    encode = "json"
  )
  
  parse_os_response(response, parse_data_function =  "parse_data")
  
}

```

```{r example-get_os_query, eval=FALSE}

# os_test_url <- Sys.getenv("OSTESTURL")
# os_test_username <- Sys.getenv("OSUSERNAME")
# os_test_password <- Sys.getenv("OSPASSWORDTEST")
# 
# auth_repo <- auth_os(url = os_test_url,
#                      username = os_test_username,
#                      password = os_test_password)
# 
# get_os_query(auth_repo, query_id = 114,
#              driving_form = "Specimen",
#              wide_row_mode = "OFF",
#              start_at = 0,
#              max_results = 5)
```

```{r tests-get_os_query}
test_that("get_os_query works", {
  expect_true(inherits(get_os_query, "function")) 
})
```

# get_bulk_query

```{r function-get_bulk_query}
#' Execute Bulk Query
#'
#' Execute the "query" method multiple times to fetch all data by page.
#'
#' @param auth_response The authentication response obtained from `auth_os`.
#' @param query_id The saved query identifier.
#' @param driving_form The driving form for the query (default is "Specimen").
#' @param wide_row_mode Specifies whether multi-valued attributes result in a single row or one row per value (default is "OFF"). Other permitted values are SHALLOW and DEEP.
#' @param page_size Page size for each query.
#' @param max_pages Maximum number of pages to fetch.
#'
#' @return A data table containing the results of the bulk query.
#'

#' @note Make sure to provide an HTTP response with the appropriate structure for parsing.
#' @export
get_bulk_query <- function(auth_response,
                           query_id,
                           driving_form = "Specimen",
                           wide_row_mode = "OFF",
                           page_size = 5000,
                           max_pages = 10000) {
  # List to store query results
  results_list <-vector(mode = "list", length = max_pages) 
  row_numbers <- vector(mode = "numeric", length = max_pages) 
  for (i in seq_len(max_pages)) {
    j = i-1
    start_at <- j * page_size
    max_results <- page_size
    
    # Execute the query for the current page
    results <- get_os_query (auth_response,
                             query_id,
                             driving_form, 
                             wide_row_mode,
                             start_at,
                             max_results)
    
    # Extract rows from the results
    rows_count <- nrow(results)
    
    
    if (!is.null(results)) {
      results_list[[i]] <- results  # Store the results in the list
      row_numbers[i] <- rows_count  # Store the number of rows retrieved
      cli::cli_alert_success(paste0(num_thousandth_sep(sum(row_numbers)),
                                    " rows retrieved"))
      
    } else {
      break  # No more data, exit the loop
    }
  }
  
  
  # Remove  0 column DFs
  results_list <- results_list[sapply(results_list, function(x) !is.null(x))]
  
  # Return the results as a single data frame
  df_results = data.table::rbindlist(results_list, fill = T) 
  
  return(df_results)
}



```

```{r example-get_bulk_query, eval=FALSE}


# auth_response <- auth_os(url =  Sys.getenv("OSTESTURL"),
#                          username = Sys.getenv("OSUSERNAME"),
#                          password = Sys.getenv("OSPASSWORDTEST"))
# 
# 
# cv_samples <- get_bulk_query(auth_response, query_id = 105)
#   
# 
# cv_samples[1:5]
```

```{r tests-get_bulk_query}
test_that("get_bulk_query works", {
  expect_true(inherits(get_bulk_query, "function")) 
})
```

# parse_os_order_data

```{r function-parse_os_order_data}
#' Parse OpenSpecimen Order Data
#'
#' This function parses the response data obtained from the OpenSpecimen API and organizes it into a data frame. It assumes that the response is in a structured format suitable for conversion to a data frame.
#'
#' @param response The response data to be parsed.
#' @param remove_personal_info Logical, whether to remove personal information columns (default is TRUE).
#' @return A data table containing the parsed order data.
#'
#' @importFrom httr content
#' @importFrom data.table rbindlist as.data.table setDT
#' @note See API documentation for details on the response structure. https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/259457077/Retrieve+list+of+Orders
#'
#' @export
parse_os_order_data <- function(response, remove_personal_info = TRUE){
  
  # Parse the content from the response
  cont <- content(response, as = "parsed")
  
  # Create a data frame by converting each element in the list to a data.table
  df <- lapply(cont, function(x) {
    unlist(x, recursive = FALSE) %>% 
      as.data.table()
  }) %>% rbindlist(fill = TRUE) %>%
    janitor::clean_names() # Clean up column names
  
  setDT(df)
  
  if(isTRUE(remove_personal_info)){
    # Remove personal information columns
    nms <- names(df)
    personal_info <- nms[grepl("email|phone|name$", nms)]
    personal_info <- personal_info[!grepl("institute", personal_info)]
    df[, (personal_info) := NULL]
    
    
  }
  
  return(df)
}

```

```{r example-parse_os_order_data}
#parse_os_order_data()
```

```{r tests-parse_os_order_data}
test_that("parse_os_order_data works", {
  expect_true(inherits(parse_os_order_data, "function")) 
})
```

# get_orders

```{r function-get_orders}
#' Get Orders
#'
#' Use this function to retrieve distribution orders in the OpenSpecimen application.
#' The function sends an HTTP GET request to the OpenSpecimen server to fetch details of distribution orders.
#'
#' @param auth_response Authentication response object obtained from the OpenSpecimen API.
#' @param include_stats If TRUE, includes statistics in the response (optional, default is TRUE).
#' @param start_at Starting row of the result (optional).
#' @param max_results Maximum number of records to fetch (optional).
#'
#' @return A data frame containing the details of distribution orders, or NULL if an error occurs.
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' auth_response <- authenticate_user(username = "your_username", password = "your_password")
#' orders <- get_orders(auth_response)
#' }
#'
#' @seealso \code{\link{auth_os}}, \code{\link{parse_os_response}}, \code{\link{parse_os_order_data}}
#'
#' @export
get_orders <- function(auth_response, include_stats = TRUE, start_at = NULL, max_results = NULL) {
  
  # URL to get distribution orders
  # For more details, refer to: https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1115667/Get+Distribution+Orders
  url <- paste0(auth_response$url, "/distribution-orders")
  
  # Specify the content type as JSON in the header
  headers <- httr::add_headers(
    "Content-Type" = "application/json",
    "X-OS-API-TOKEN" = auth_response$auth_response$token
  )
  
  # Construct query parameters based on provided arguments
  query_params <- list(
    includeStats = include_stats,
    startAt = start_at,
    maxResults = max_results
  )
  
  # Remove NULL parameters
  query_params <- query_params[!sapply(query_params, is.null)]
  
  # Append query parameters to the URL
  if (length(query_params) > 0) {
    url <- httr::modify_url(url, query = query_params)
  }
  
  # Make the GET request for the orders
  response <- httr::GET(url = url, config = headers)
  
  # Parse the response and return the results
  results <- parse_os_response(response, parse_data_function = "parse_os_order_data")
  
  # If inherits data.frame, return results, else return NULL
  if (inherits(results, "data.frame")) {
    return(results)
  } else {
    return(NULL)
  }
}



```

```{r example-get_orders}
#get_orders()
```

# get_bulk_orders

```{r function-get_bulk_orders}
#' Get OpenSpecimen Orders in Bulk
#'
#' This function retrieves a list of orders from the OpenSpecimen API in bulk, handling pagination and combining results. It uses the provided authentication response and optional query parameters for customization.
#'
#' @param auth_response The authentication response obtained from `auth_os`.
#' @param include_stats Logical, whether to include statistics (default is TRUE).
#' @param page_size Integer, the number of results to retrieve per page (default is 250).
#' @param max_pages Integer, the maximum number of pages to retrieve (default is 10,000).
#'
#' @return A data frame containing the aggregated order data from multiple pages.
#'

#' @importFrom httr GET add_headers status_code
#'
#' @note This function allows you to efficiently retrieve orders from OpenSpecimen in bulk while handling pagination and result aggregation.
#'
#' @export
get_bulk_orders <- function(auth_response, 
                            include_stats = TRUE, 
                            page_size = 250,
                            max_pages = 10000) {
  
  # List to store query results
  results_list <-  vector(mode = "list", length = max_pages)
  row_numbers <- vector(mode = "numeric", length = max_pages) 
  
  for (i in  seq_len(max_pages)) {
    j = i - 1
    start_at <- j * page_size
    max_results <- page_size
    
    results <- get_orders(auth_response, include_stats, start_at, max_results)
    
    rows_count <- nrow(results)
    
    if (rows_count > 0) {
      
      results_list[[i]] <- results  # Store the results in the list
      row_numbers[i] <- rows_count  # Store the number of rows retrieved
      cli::cli_alert_success(paste0(num_thousandth_sep(sum(row_numbers)),
                                    " rows retrieved"))
      
    } else {
      
      break  # No more data, exit the loop
    }
  }
  
  # Remove 0-column data frames
  results_list <- results_list[sapply(results_list, function(x) !is.null(x))]
  
  # Return the results as a single data frame
  df_results = data.table::rbindlist(results_list, fill = TRUE) 
  
  return(df_results)
}

```



```{r example-get_bulk_orders}
#get_bulk_orders()
```



```{r tests-get_bulk_orders}
test_that("get_bulk_orders works", {
  expect_true(inherits(get_bulk_orders, "function")) 
})
```




```{r tests-get_orders}
test_that("get_orders works", {
  expect_true(inherits(get_orders, "function")) 
})
```


# parse_order_detail_data

```{r function-parse_order_detail_data}
#' Parse OpenSpecimen Order Detail Data
#'
#' This function parses the response content from the OpenSpecimen API for order details and organizes it into a data.table.
#'
#' @param response The response object from the Open Specimen API.
#' @param remove_personal_info Logical, whether to remove personal information columns (default is TRUE).
#'
#' @return A data.table containing the parsed order detail data.
#'
#' @importFrom data.table as.data.table data.table
#' @import janitor
#'
#' @export
# review the code below and see if you can make it more efficient 
parse_order_detail_data <- function(response, remove_personal_info = TRUE) {
  
  # Parse the response content
  parsed_cont <- content(response, "parsed") 
  
  # Unlist the parsed content
  parsed_1 <- unlist(parsed_cont, recursive = FALSE) 
  
  # Extract extension details
  extension_details <- parsed_1$distributionProtocol.extensionDetail 
  
  # Extract attribute details
  attr_dp <- extension_details$attrs
  
  # Create clean column names
  col_nms <- sapply(attr_dp, function(x) x$caption) %>% 
    janitor::make_clean_names()
  
  # Extract attribute values
  values <- lapply(attr_dp, function(x) x$value)
  
  # Set names for values
  names(values) <- col_nms
  
  # Convert values to data.table
  dt1 = as.data.table(values)
  
  # Remove extension details from parsed content
  parsed_1$distributionProtocol.extensionDetail <- NULL
  
  # Extract distributing sites
  dist_sites <- parsed_1$distributionProtocol.distributingSites %>%
    unlist() %>%
    paste0(collapse = ",")
  
  # Convert distributing sites to data.table
  dist_sites <- data.table(distributing_site = dist_sites)
  
  # Remove distributing sites from parsed content
  parsed_1$distributionProtocol.distributingSites <- NULL
  
  # Unlist the remaining parsed content
  
  
  parsed_2 <- unlist(parsed_1, recursive = TRUE)
  
  
  # Convert parsed content to data.table
  dt2 = as.data.table(as.list(parsed_2))
  
  # Combine data.tables
  dt_final <- cbind(dt2, dt1, dist_sites)
  
  # Clean column names
  make_clean_os_names(dt_final)
  
  # Rename principal investigator columns
  nms = names(dt_final)
  nmspi <- nms[grepl("principal_investigator|distribution_protocol_report", nms)]
  nmspi_new <- gsub("distribution_protocol_", "", nmspi)
  setnames(dt_final, nmspi, nmspi_new)
  
  # Delete personal information columns if specified
  
  if (isTRUE(remove_personal_info)) {
    
    personal_info <- nms[grepl("email|phone|name", nms)]
    personal_info <- personal_info[!grepl("institute", personal_info)]
    dt_final[, (personal_info) := NULL]
  }
  
  # Return the final data.table
  dt_final
}


```

```{r example-parse_order_detail_data}

# order_detail <- parse_order_detail_data(response)

```

```{r tests-parse_order_detail_data}
test_that("parse_order_detail_data works", {
  expect_true(inherits(parse_order_detail_data, "function")) 
})
```



# get_order_detail

```{r function-get_order_detail}
#' Get OpenSpecimen Order Detail
#'
#' This function retrieves details of a specific order from the OpenSpecimen API using the provided authentication response and order ID.
#'
#' @param auth_response The authentication response obtained from `auth_os`.
#' @param order_id The ID of the order to retrieve details for.
#' @param return_numeric Logical, whether to return timestamps as numeric values (default is TRUE). This function is parsed to parse order detail function
#' @return A data table containing the parsed order detail data.
#'
#' @importFrom httr GET status_code 
#' @export
get_order_detail <- function(auth_response, order_id, return_numeric = F) {
  
  # Check if order_id is an integer
  if (isTRUE(round(order_id) != order_id)) {
    stop("order_id must be an integer")
  }
  
  # Extract the authentication token from the response
  auth_token <- auth_response$auth_response$token
  url <- auth_response$url
  
  # Specify the content type as JSON in the header
  headers <- add_headers(
    "Content-Type" = "application/json",
    "X-OS-API-TOKEN" = auth_token
  )
  
  # Construct the URL for the order detail
  order_url <- paste0(url, "/distribution-orders/", order_id)
  
  # Make the GET request for the order detail
  response <- GET(
    url = order_url,
    config = headers,
    encode = "json"
  )
  
  
  results <- parse_os_response(response,
                               parse_data_function = "parse_order_detail_data",
                               return_numeric = return_numeric)
  
  if(inherits(results, "data.frame")) {
    
    return(results)
    
  }else {
    
    return(NULL)
  }
  
}

```






```{r example-get_order_detail}
# extract order 392 from os

# df = get_order_detail(auth_response, order_id = 392)

```



```{r tests-get_order_detail}
test_that("get_order_detail works", {
  expect_true(inherits(get_order_detail, "function")) 
})
```


# get_bulk_order_detail

```{r function-get_bulk_order_detail}
#' Get Bulk OpenSpecimen Order Details
#'
#' This function retrieves details for a bulk list of orders from the OpenSpecimen API using the provided authentication response and order IDs.
#'
#' @param auth_response The authentication response obtained from `auth_os`.
#' @param orders_ids A vector of order IDs for which details are to be retrieved.
#' @param ... Additional parameters to be passed to `get_order_detail`.
#'
#' @return A data.table containing the parsed details for the specified orders.
#'
#' @export
get_bulk_order_detail <- function(auth_response, orders_ids, ...) {
  
  # Check if orders_ids is a vector of integers
  if (isTRUE(any(round(orders_ids) != orders_ids))) {
    stop("orders_ids must be an integer")
  }
  
  # Convert lapply to a for loop and print after every 100 iterations
  # Use tryCatch to handle errors
  
  list_dfs <- vector("list", length(orders_ids))
  
  for (i in seq_along(orders_ids)) {
    
    list_dfs[[i]] <- tryCatch(
      get_order_detail(order_id = orders_ids[i], auth_response, ...),
      error = function(e) {
        cli::cli_alert_warning(paste0("Error in order_id: ", orders_ids[i], " ", e$message))
        return(NULL)
      }
    )
    
    if (i %% 100 == 0) {
      cli::cli_alert_success(
        paste0("Retrieved ", i, " orders",
               " out of ", length(orders_ids))
      )
    }
  }
  
  ## Combine the list of data.tables into a single data.table
  dt_final = data.table::rbindlist(list_dfs, fill = TRUE)
  
  cli::cli_alert_success(paste0("All ", i, " orders retrieved"))
 # timestamp_to_date.data.frame(dt_final, return_numeric = TRUE)
  return(dt_final)
  
}

```



```{r example-get_bulk_order_detail}
#get_bulk_order_detail()
```



```{r tests-get_bulk_order_detail}
test_that("get_bulk_order_detail works", {
  expect_true(inherits(get_bulk_order_detail, "function")) 
})

```


# parse_os_oder_list

```{r function-parse_os_oder_list}
#' Parse OpenSpecimen Order Item List
#'
#' This function parses a list of OpenSpecimen order items list (distributed samples) and returns a data.table with selected fields.
#'
#' @param response Response object from httr::GET [Link to Api details](https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/259457102/Retrieve+Order+Items)
#'
#' @return A data.table containing parsed information from the OpenSpecimen order items.
#' @importFrom httr content
#' @importFrom data.table rbindlist as.data.table
#' @note  [Link to Api details](https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/259457102/Retrieve+Order+Items)
#' @export
parse_os_oder_list <- function(response) {
  
  oder_items <- content(response, "parsed")
  nms <- c("orderId", "orderName", "status", 
           "specimen.ppid", "specimen.label",
           "specimen.eventLabel",
           "specimen.cpShortTitle", 
           "specimen.visitDate",
           "specimen.type",
           "specimen.availabilityStatus")
  
  df_list <- lapply(seq_along(oder_items), function(x) {
    
    list_x = oder_items[[x]]
    
    vec_unlist <- unlist(list_x, recursive = TRUE)
    nms_all = names(vec_unlist)
    nms <- nms[nms %in% nms_all]
    vec_unlist[nms] %>% as.list() %>% 
      as.data.table()
    
  })
  
  dt <- rbindlist(df_list, fill = TRUE)
  
  make_clean_os_names(dt)
  
  return(dt)
  
}

```

```{r example-parse_os_oder_list}

#parse_os_oder_list(oder_items)

```

```{r tests-parse_os_oder_list}
test_that("parse_os_oder_list works", {
  expect_true(inherits(parse_os_oder_list, "function")) 
})
```

# get_order_items

```{r function-get_order_items}

#' Retrieve Order Items from OpenSpecimen
#'
#' This function retrieves the details of order items of the requested order from OpenSpecimen.
#'
#' @param auth_response Authentication response from OpenSpecimen.
#' @param order_id ID of the order whose items are requested.
#'
#' @return A data.table containing parsed information from the OpenSpecimen order items.
#'
#' @importFrom httr GET add_headers
#' @export
get_order_items <- function(auth_response, order_id) {
  
  if (isTRUE(round(order_id) != order_id)) {
    stop("order_id must be an integer")
  }
  
  # Extract the authentication token from the response
  auth_token <- auth_response$auth_response$token
  url <- auth_response$url
  
  # Specify the content type as JSON in the header
  headers <- add_headers(
    "Content-Type" = "application/json",
    "X-OS-API-TOKEN" = auth_token
  )
  
  # Make the GET request for the query
  response <- GET(
    url = paste0(url, "/distribution-orders/", order_id, "/items"),
    config = headers,
    encode = "json"
  )
  
  # Parse the response and return the results
  results <- parse_os_response(response,
                               parse_data_function = "parse_os_oder_list")
  
  # If inherits data.frame, return results, else return NULL
  if (inherits(results, "data.frame")) {
    return(results)
  } else {
    return(NULL)
  }
}
```


```{r example-get_order_items}
#get_order_items()
```


```{r tests-get_order_items}
test_that("get_order_items works", {
  expect_true(inherits(get_order_items, "function")) 
})
```

# parse_all_sites

```{r function-parse_all_sites}
#' Parse All Sites
#'
#' Use this function to parse the response content from the OpenSpecimen API
#' and extract the details of all sites.
#'
#' @param response The response object obtained from the OpenSpecimen API.
#'
#' @return A data frame containing the details of all sites.
#'
#' @export
parse_all_sites <- function(response) {
  
  # Extract the content from the response
  mycontent <- content(response, "parsed")
  
  # Extract the sites from the content
  df <- lapply(mycontent, as.data.table) %>%
    rbindlist(fill = TRUE)
  
  # Return the sites
  return(df)
  
}

```

```{r example-parse_all_sites}
#parse_all_sites()
```

```{r tests-parse_all_sites}
test_that("parse_all_sites works", {
  expect_true(inherits(parse_all_sites, "function")) 
})
```


# get_bulk_order_items

```{r function-get_bulk_order_items}
#' Retrieve Order Items for Multiple Orders
#'
#' This function retrieves order items for multiple orders specified by their IDs.
#'
#' @param auth_response Authentication response obtained from the OpenSpecimen API.
#' @param orders_ids Vector of integers representing the IDs of the orders to retrieve items for.
#' @param ... Additional parameters to be passed to `get_order_items` function.
#'
#' @return A data.table containing the retrieved order items.
#'
#' @examples
#' \dontrun{
#' auth_response <- auth_os(url, username, password)
#' orders_data <- get_bulk_order_items(auth_response, c(1, 2, 3))
#' }
#'
#' @export
get_bulk_order_items <- function(auth_response, orders_ids, ...) {
  
  # check orders_ids is a vector of integers
  if(isTRUE(any(round(orders_ids) != orders_ids))) {
    stop("orders_ids must be an integer")
  }
  
  # use tryCatch to handle errors
  
  list_dfs <- vector("list", length(orders_ids))
  
  for (i in seq_along(orders_ids)) {
    
    list_dfs[[i]] <- tryCatch(
      get_order_items(auth_response, order_id = orders_ids[i], ...),
      error = function(e) {
        cli::cli_alert_warning(paste0("Error in order_id: ", orders_ids[i], " ", e$message))
        return(NULL)
      }
    )
    
    if (i %% 10 == 0) {
      cli::cli_alert_success(
        paste0("Retrieved ", i, " orders",
               " out of ", length(orders_ids))
      )
    }
  }
  
  ## combine the list of data.tables into a single data.table
  dt_final = data.table::rbindlist(list_dfs, fill = TRUE)
  
  cli::cli_alert_success(paste0("Done: orders retrieved"))
  
  return(dt_final)
  
}

```


```{r example-get_bulk_order_items}
#get_bulk_order_items()
```



```{r tests-get_bulk_order_items}
test_that("get_bulk_order_items works", {
  expect_true(inherits(get_bulk_order_items, "function")) 
})
```




# get_all_sites

```{r function-get_all_sites}
#' Get All Sites
#'
#' Use this function to retrieve all the sites in the OpenSpecimen application.
#' The function sends an HTTP GET request to the OpenSpecimen server to fetch 
#' details of all the sites.
#'
#' @param auth_response Authentication response object obtained from the OpenSpecimen API.
#'
#' @param startAt Starting row of the result (optional).
#' @param maxResults Maximum number of records to fetch (optional). By default, it will be 100.
#' @param name Result contains all sites which have a name containing the given value (optional).
#' @param exactMatch If TRUE, considers the name parameter as an exact match with the site name (optional).
#' @param institute Result contains all sites which belong to the given institute (optional).
#' @importFrom httr GET add_headers modify_url
#' @return A data frame containing the details of all sites, or NULL if an error occurs.
#'
#'
#' @seealso \code{\link{auth_os}}, \code{\link{parse_os_response}}, \code{\link{parse_all_sites}}
#'
#' @export
get_all_sites <- function(auth_response, startAt = NULL, maxResults = 500, name = NULL, exactMatch = FALSE, institute = NULL) {
  
  # URL to get all sites
  # For more details, refer to: https://openspecimen.atlassian.net/wiki/spaces/CAT/pages/1115685/Get+All+Sites
  url <- paste0(auth_response$url, "/sites")
  
  # Specify the content type as JSON in the header
  headers <- add_headers(
    "Content-Type" = "application/json",
    "X-OS-API-TOKEN" = auth_response$auth_response$token
  )
  
  # Construct query parameters based on provided arguments
  query_params <- list(
    startAt = startAt,
    maxResults = maxResults,
    name = name,
    exactMatch = exactMatch,
    institute = institute
  )
  
  # Remove NULL parameters
  query_params <- query_params[!sapply(query_params, is.null)]
  
  # Append query parameters to the URL
  if (length(query_params) > 0) {
    url <- modify_url(url, query = query_params)
  }
  
  # Make the GET request for the query
  response <- GET(url = url, config = headers, encode = "json")
  
  # Parse the response and return the results
  results <- parse_os_response(response, parse_data_function = "parse_all_sites")
  
  # If inherits data.frame, return results, else return NULL
  if (inherits(results, "data.frame")) {
    return(results)
  } else {
    return(NULL)
  }
}




```


```{r example-get_all_sites}
#get_all_sites()
```


```{r tests-get_all_sites}
test_that("get_all_sites works", {
  expect_true(inherits(get_all_sites, "function")) 
})
```



# parse_site_details

```{r function-parse_site_details}
#' Parse OpenSpecimen Site Details
#'
#' Use this function to parse the response and extract details of a site from the OpenSpecimen application.
#'
#' @param response The API response object.
#'
#' @return A data table containing the parsed details of the site.
#'
#' @export
parse_site_details <- function(response) {
  
  # Extract the content from the response
  mycontent2 <- content(response, "parsed")
  
  # Extract extension details
  extension_details <- mycontent2$extensionDetail
  
  # Extract attribute details
  attr_dp <- extension_details$attrs
  
  # Create clean column names
  col_nms <- sapply(attr_dp, function(x) x$caption) %>% 
    janitor::make_clean_names()
  
  # Extract attribute values
  values <- lapply(attr_dp, function(x) x$value)
  
  # Set names for values
  names(values) <- col_nms
  
  # Convert values to data.table
  dt1 = as.data.table(values)
  
  # Remove extension details from parsed content
  mycontent2$extensionDetail <- NULL
  mycontent2$coordinators <- NULL
  # Convert remaining parsed content to data.table
  mycontentdf <- mycontent2 %>% as.data.table()
  
  # Combine data.tables
  mycontentdf <- cbind(mycontentdf, dt1)
  
  # Return the final data.table
  mycontentdf
  
}

```


```{r example-parse_site_details}
#parse_site_details()
```


```{r tests-parse_site_details}
test_that("parse_site_details works", {
  expect_true(inherits(parse_site_details, "function")) 
})
```



# get_os_site

```{r function-get_os_site}
#' Get OpenSpecimen Site
#'
#' Use this function to retrieve details of a site from the OpenSpecimen application.
#'
#' @param auth_response Authentication response object obtained from the OpenSpecimen API.
#' @param site_id The unique identifier of the site to fetch.
#'
#' @return A data frame containing the details of the specified site.
#'
#' @export
get_os_site <- function(auth_response, site_id) {
  
  # Get the site details
  # Specify the content type as JSON in the header
  # Extract the authentication token from the response
  auth_token <- auth_response$auth_response$token
  url <- auth_response$url
  
  headers <- add_headers(
    "Content-Type" = "application/json",
    "X-OS-API-TOKEN" = auth_token
  )
  
  # Make the GET request for the query
  response <- GET(
    url = paste0(url, "/sites/", site_id),
    config = headers,
    encode = "json"
  )
  
  # Parse the response and return the results
  results <- parse_os_response(response, 
                               parse_data_function = "parse_site_details")
  
  # If inherits data.frame, return results, else return NULL
  if (inherits(results, "data.frame")) {
    return(results)
  } else {
    return(NULL)
  }
  
}

```


```{r example-get_os_site}
#get_os_site()
```


```{r tests-get_os_site}
test_that("get_os_site works", {
  expect_true(inherits(get_os_site, "function")) 
})
```

# get_bulk_site_details

```{r function-get_bulk_site_details}
#' Get Bulk Site Details
#'
#' Use this function to retrieve details of multiple sites in bulk from the OpenSpecimen application.
#'
#' @param auth_response The authentication response object.
#' @param site_ids A vector of integers representing the IDs of the sites to retrieve details for.
#' @param ... Additional parameters to be passed to the underlying `get_os_site` function.
#'
#' @return A data table containing the details of the requested sites.
#'
#' @export
get_bulk_site_details <- function(auth_response, site_ids, ...) {
  
  # Check if site_ids is a vector of integers
  if (isTRUE(any(round(site_ids) != site_ids))) {
    stop("site_ids must be an integer")
  }
  
  # Use tryCatch to handle errors
  
  list_dfs <- vector("list", length(site_ids))
  
  for (i in seq_along(site_ids)) {
    
    list_dfs[[i]] <- tryCatch(
      get_os_site(auth_response, site_id = site_ids[i], ...),
      error = function(e) {
        cli::cli_alert_warning(paste0("Error in site id: ", site_ids[i], " ", e$message))
        return(NULL)
      }
    )
    
    if (i %% 10 == 0) {
      cli::cli_alert_success(
        paste0("Retrieved ", i, " sites",
               " out of ", length(site_ids))
      )
    }
  }
  
  ## Combine the list of data.tables into a single data.table
  dt_final = data.table::rbindlist(list_dfs, fill = TRUE)
  
  cli::cli_alert_success(paste0("Done: Site details retrieved"))
  
  return(dt_final)
  
}

```

```{r example-get_bulk_site_details}
#get_bulk_site_details()
```

```{r tests-get_bulk_site_details}
test_that("get_bulk_site_details works", {
  expect_true(inherits(get_bulk_site_details, "function")) 
})
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/OpenSpecimenAPI.Rmd", 
               vignette_name = "Open-Specimen-API")
```


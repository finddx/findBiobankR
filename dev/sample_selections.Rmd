---
title: "Sample Selections"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->


# convert_os_df_to_wide 

```{r function-convert_os_df_to_wide }



#' Convert  OS data to wide
#' 
#' Convert OS data to wide and merge with clinical data
#' 
#' @param clinical_df A data frame with clinical data at Find typically from Open Clinica.
#' @param specimen_df A data frame with specimen data at Find generally Open Specimen.
#' @param os_aliquot_names A vector of the aliquot names that you want to use. 
#' @param join_by_col A column used to merge clinical data and specimen data
#' @param join_function A function in char to join with. Recommended to use
#'  dplyr merge function eg left_join, inner_join etc. Recommended to load dplyr 
#' @param specimen_col The column containing specimen names.
#'  At find usually Specimen Requirement name
#' @param clinical_vars A vector of clinical variables.
#'  Ideally variables that usually describe patient characteristics eg sex, 
#'  disease information etc
#' @param specimen_label_col Column containing specimen IDS in Open Specimen this is 
#'  specimen label
#' @importFrom janitor make_clean_names
#' @importFrom data.table setnames setDT 
#' @importFrom purrr reduce
#' @return A wide data frame with one row per participant and one column for
#'   each aliquot name and the number of aliquots and the specimen labels for
#'   that aliquot.
#'
#' @export

convert_os_df_to_wide <- function(clinical_df,
                                  specimen_df, 
                                  join_by_col,
                                  specimen_col,
                                  specimen_label_col,
                                  clinical_vars = NULL ,
                                  os_aliquot_names,
                                  join_function = "left_join") {
  
  # Check if input data frames are provided
  if (is.null(clinical_df) || is.null(specimen_df)) {
    stop("Input data frames 'clinical_df' and 'specimen_df' are required.")
  }
  
  # Check if join_by_col and specimen_col are present in the data frames
  if (!(join_by_col %in% names(clinical_df)) || !(join_by_col %in% names(specimen_df))) {
    stop("The column 'join_by_col' does not exist in the data frames.")
  }
  
  if (!(specimen_col %in% names(specimen_df))) {
    stop("The column 'specimen_col' does not exist in the 'specimen_df' data frame.")
  }
  
  # Check if os_aliquot_names is provided
  if (length(os_aliquot_names) == 0) {
    stop("The 'os_aliquot_names' vector is empty.")
  }
  
  # Clean the aliquot names.
  os_aliquot_names_clean <- make_clean_names(os_aliquot_names)
  
  # Create a list of data frames, one for each aliquot name.
  list_dfs = vector(mode = "list",
                    length = length(os_aliquot_names))
  
  for (i in seq_along(os_aliquot_names)) {
    
    aliq_name = os_aliquot_names[i]
    
    aliq_col_name = os_aliquot_names_clean[i]
    
    no_aliquots = paste0("NP_aliqN_",
                         aliq_col_name)
    aliquots_spec_label = paste0("NP_labels_", 
                                 aliq_col_name)
    
    new_nms = c(no_aliquots, aliquots_spec_label)
    
    old_nms = c("NP_aliqN", "NP_labels")
    # calculate aliquot numbers and 
    
    aliquot_samples_df <- specimen_df[get(specimen_col) == aliq_name,
                                      list(NP_aliqN = .N,
                                        NP_labels = list(get(specimen_label_col))),
                                      by = join_by_col]
    
    
    setnames(aliquot_samples_df,
             old_nms, 
             new_nms)
    
    list_dfs[[i]] = aliquot_samples_df
    
  }
  ## function use to merge data frames
  join_function <- match.fun(join_function)
  # Combine the list of data frames into a single data frame.
  final_df <- list_dfs %>% 
    reduce(join_function,
           by = join_by_col)
  
  # Set the data frame as a data table.
  
  setDT(final_df)
  
  # select only the variables required from clinical data
  if(!is.null(clinical_vars)){
    
    clinical_vars = c(join_by_col, clinical_vars)
    
    clinical_df = clinical_df[, .SD, 
                              .SDcols = clinical_vars]
  }
   ## merge with clinical df
  final_df <- merge(clinical_df,
                    final_df,
                    by = join_by_col,
                    all.x = T)
  
  
  # Return the wide data frame.
  final_df
}
```



```{r example-convert_os_df_to_wide }
library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)

knitr::kable(clin_specs[1:10, ])
```





```{r tests-convert_os_df_to_wide }
test_that("convert_os_df_to_wide  works", {
  library(data.table)
  data("tb_data", package = "findBiobankR")
  setnames(tb_data, "ppid", "ppid2")
  data("tb_specimen_df", package = "findBiobankR")
  
  expect_error( convert_os_df_to_wide(clinical_df = tb_data,
                                      specimen_df = tb_specimen_df, 
                                      join_by_col = "ppid",
                                      specimen_col ="specimen_type" ,
                                      clinical_vars = clinical_cols ,
                                      os_aliquot_names = c("Serum", "Plasma")),
                regxp ="The column 'join_by_col' does not exist in the data frames." )
})
```



# select_one_aliquot


```{r function-select_one_aliquot}
#' Title Select One aliquot 
#' 
#' Description This function selects a specific aliquot label from a list of objects/ A list column 
#' @param x The input is a list column or a list of vectors 
#' @param aliquot_number The number indicating the position of the desired aliquot label. Defaults to 1.
#' @return A list of selected aliquot labels.
#' @return A vector
#' 
#' @export


select_one_aliquot <- function(x, aliquot_number = 1){
  
  # Check if x is a list
  if (!is.list(x)) {
    stop("Parameter 'x' must be a list.")
  }
  # Check if aliquot_number is numeric
  if (isFALSE(aliquot_number %%1==0 | aliquot_number > 0)) {
    stop("Parameter 'aliquot_number' must be a non negative integer.")
  }
  
  #a list to store the selected aliquot labels
  list_aliquots <- lapply(seq_along(x),function(z){
    
    zx = x[[z]]
    
    if(is.null(zx) ){
      
      ans = NA
      
    }else if(aliquot_number > length(zx)){
      
      warning("Subscript out of bounds returning NA")
      
      ans = NA
      
    }else{
      
      ans = zx[[aliquot_number]] %>% unlist()
    }
    
    ans
  })
  
  unlist(list_aliquots)
}
```




```{r example-select_one_aliquot}
library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                      specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)

##
clin_specs[, select_one_aliquot(NP_labels_serum)]

# or data table way
clin_specs[, serum_aliquot_dt := select_one_aliquot(NP_labels_serum)]
# or tidyverse way
clin_specs %>%
  mutate(serum_aliquot_dp := select_one_aliquot(NP_labels_serum))

knitr::kable(clin_specs[1:10, ])

samples_list <- list(c("TB0990100010101001", "TB0990100010101002", "TB0990100010101003"),
                     c("TB0990100020101001", "TB0990100020101002", "TB0990100020101003"), 
                     c("TB0990100030101001", "TB0990100030101002", "TB0990100030101003"),
                     c("TB0990100040101001", "TB0990100040101002", "TB0990100040101003"),
                     c("TB0990100050101001", "TB0990100050101002", "TB0990100050101003"
                     ))
select_one_aliquot(samples_list, aliquot_number = 2)
```






```{r tests-select_one_aliquot}
test_that("select_one_aliquot works", {
  
  samples_list <- list(c("TB0990100010101001", 
                         "TB0990100010101002",
                         "TB0990100010101003"))
  
  expect_warning(select_one_aliquot(samples_list, aliquot_number = 4),
                 regxp ="Subscript out of bounds returning NA" )
  expect_equal(select_one_aliquot(samples_list, aliquot_number = 1),"TB0990100010101001" )
})
```


# select_many_aliquots


```{r function-select_many_aliquots}
#' Title Select many aliquots 
#'
#' Description Selects multiple aliquots labels from a list of lists.
#'
#' @param x A list of lists containing aliquot labels.
#' @param aliquots The number of aliquots to select.
#'
#' @return A list of vectors, each containing the selected aliquot labels.
#'
#' @export

select_many_aliquots <- function(x, aliquots) {
  
  if (aliquots <= 0){
    stop("Number of aliquots must be specified and greater than 0")
  }
  
  aliquot_pos <- seq_len(aliquots)
  
  nms <- paste0("aliquots", aliquot_pos)
  
  list_aliquots <- vector(mode = "list",
                          length = aliquots)
  
  list_aliquots <- lapply(seq_along(aliquot_pos), function(i){
    
    aliquot_label_i <- select_one_aliquot(x, aliquot_number = i)
    aliquot_label_i
    
    
    
  }
  )
  names(list_aliquots) <- nms
  
  list_aliquots
}
```


```{r example-select_many_aliquots}

samples_list <- list(c("TB0990100010101001", "TB0990100010101002", "TB0990100010101003"),
                     c("TB0990100020101001", "TB0990100020101002", "TB0990100020101003"), 
                     c("TB0990100030101001", "TB0990100030101002", "TB0990100030101003"),
                     c("TB0990100040101001", "TB0990100040101002", "TB0990100040101003"),
                     c("TB0990100050101001", "TB0990100050101002", "TB0990100050101003"
                     ))

## Select two aliquots per patient
aliquots_selected <- select_many_aliquots(samples_list, 
                                          aliquots = 2)

aliquots_selected
```


```{r tests-select_many_aliquots}

library(testthat)

# Define test cases
test_that("select_many_aliquots returns correct aliquots", {
  samples_list <- list(
    c("TB0990100010101001", "TB0990100010101002", "TB0990100010101003"),
    c("TB0990100020101001", "TB0990100020101002", "TB0990100020101003"),
    c("TB0990100030101001", "TB0990100030101002", "TB0990100030101003"),
    c("TB0990100040101001", "TB0990100040101002", "TB0990100040101003"),
    c("TB0990100050101001", "TB0990100050101002", "TB0990100050101003")
  )
  
  # Test case 1
  expected_result_1 <- list(
   aliquots1 =  c("TB0990100010101001", "TB0990100020101001", 
                  "TB0990100030101001", "TB0990100040101001", 
                  "TB0990100050101001"),
    aliquots2 = c("TB0990100010101002", "TB0990100020101002",
                  "TB0990100030101002", "TB0990100040101002",
                  "TB0990100050101002"),
   
   aliquots3 =  c("TB0990100010101003", "TB0990100020101003",
                  "TB0990100030101003", "TB0990100040101003", 
                  "TB0990100050101003"))
   
    result_1 <- select_many_aliquots(samples_list, 3)
    expect_equal(result_1, expected_result_1)
    
    # Test case 2
    expected_result_2 <- list(
      aliquots1 = c("TB0990100010101001", "TB0990100020101001", 
                    "TB0990100030101001", "TB0990100040101001",
                    "TB0990100050101001"
))
    result_2 <- select_many_aliquots(samples_list, 1)
    
    expect_equal(result_2, expected_result_2)
    
    
    # Test case 3
    expect_error(select_many_aliquots(samples_list, 0), 
                 regxp = "Number of aliquots must be specified and greater than 0")
})
  
  
```
  
 # select_patients_per_group
    
```{r function-select_patients_per_group}
#' Select patients per group
#' For sample selections often this is based on patient groups and required number of patients maybe be different per patient group. This function helps with this selection 
#' @param df A data.frame with clinical data and number of aliquots per patient column 
#' @param patient_group_col The column name with patient characterization 
#' @param patient_groups A vector of patient group. This names should be categories in patient_group_col
#' @param number_per_group A vector same length indicating how many patient to select per group 
#' @param sort_cols column(s) names that should be used to sort your data frame. We prefer to select patients with higher of aliquots 
#' @importFrom data.table setDT rbindlist setorderv
#' @return data.table 
#' 
#' @export
select_patients_per_group <- function(df, 
                            patient_group_col,
                            patient_groups,
                            number_per_group,
                            sort_cols
                            ){
   # Check that the number_per_group vector is the same length as the patient_groups vector
  if (length(number_per_group) != length(patient_groups)) {
    stop("The number_per_group vector is not the same length as the patient_groups vector")
  }
  
  setDT(df)
  list_selected = vector(mode = "list", 
                         length = length(patient_groups))
  
  for (i in seq_along(patient_groups)) {
    
    patient_grp = patient_groups[i]
    no_i = number_per_group[i]
    df1 = df[get(patient_group_col)  ==patient_grp ]
    if(isFALSE(nrow(df1) >= no_i)){
      
      stop_mess = glue::glue("Patient group {patient_grp} has insuficient number of participants for \\
                          group, The number of participant required \\
                          are {no_i}, the number available is {nrow(df1)}")
      stop(stop_mess)
    }
    setorderv(df1,cols = sort_cols, order = -1L)
    
    df1 = df1[1:no_i]
    list_selected[[i]] = df1
    
  }
  df_final = rbindlist(list_selected)
  df_final
}
```



```{r example-select_patients_per_group}

library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


## select 2 patients per group 
patient_groups  <- c("TB, Neg", "TB, Pos")
number_per_group  <- c(2, 2)
sort_cols = "NP_aliqN_serum"
clin_specs_2 <- select_patients_per_group(df = clin_specs, 
                                          patient_group_col = "tb_group",
                                          patient_groups = patient_groups,
                                          number_per_group = number_per_group,
                                          sort_cols = sort_cols)


```

 
```{r tests-select_patients_per_group}

test_that("select_patients_per_group works", {
  expect_true(inherits(select_patients_per_group, "function")) 
})


```

# selected_aliquots_df
    
```{r function-selected_aliquots_df}
#' Create a data frame with selected aliquots in long format
#'
#' @description
#' This function is used in conjunction from other findBiobankR package. It accepts an a data drame/data.table 
#' with selected aliquots as a column 
#' @seealso findBiobank::select_one_aliquot
#' @param clin_specs A data from with the selected aliquots as column
#' @param aliquot_cols Column names of the selected aliquots in `clin_specs` data frame
#' @param ppid_col Participant ID column 
#' @param aliquot_name_col The name of the variable name after data.table::melt
#' @param spec_label_col The name of the value name after data.table::melt
#' @importFrom stringr str_replace_all str_trim
#' @importFrom data.table melt setDT
#' @return a data.table with `ppid, specimen_label_col` columns 
#' 
#' @export
#' 
selected_aliquots_df <- function(clin_specs,
                                 aliquot_cols,
                                 ppid_col = "Participant_PPID",
                                 aliquot_name_col = "aliquot_name",
                                 spec_label_col = "specimen_label"){
  
  
  data_name = deparse(substitute(clin_specs))
  
  if(isFALSE(inherits(clin_specs, "data.table"))){
    
    msg = sprintf("%s is a data.frame converting this to data.table", data_name)
    message(msg)
  }
  nms_selected_labels <- c(ppid_col,aliquot_cols)
  
  urien23selected <- clin_specs[, .SD, .SDcols = nms_selected_labels]
  
  
  
  urien23selected_m <- melt(urien23selected, 
                            id.vars =ppid_col,
                            variable.name = aliquot_name_col,
                            value.name = spec_label_col)
  
  urien23selected_m[, (aliquot_name_col) := NULL]
  
  urien23selected_m <- urien23selected_m[!is.na(get(spec_label_col))]
  
  urien23selected_m <- unique(urien23selected_m,
                              by ="specimen_label")
  urien23selected_m[, (spec_label_col) := str_replace_all(get(spec_label_col), '"|\\)|\\(|^c', '')]
  urien23selected_m[, (spec_label_col) := str_trim(get(spec_label_col))]
  urien23selected_m
}
```
  
```{r example-selected_aliquots_df}

library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                      specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


clin_specs[, serum_aliquot := select_one_aliquot(NP_labels_serum, aliquot_number = 1 )]
clin_specs[, plasma_aliquot := select_one_aliquot(NP_labels_plasma, aliquot_number= 1 )]
# or tidyverse way
selected_aliquots_df(clin_specs,
                     aliquot_cols = c("serum_aliquot","plasma_aliquot"),
                     ppid_col = "ppid")
```
  
```{r tests-selected_aliquots_df}
test_that("selected_aliquots_df works", {
  expect_true(inherits(selected_aliquots_df, "function")) 
})
```

# make_clean_os_names
    
```{r function-make_clean_os_names}
#' Clean Open Specimen Names
#' 
#' @description
#' Data set from Open specimen normally come with very programming unfriendly column
#' names with repeat suffixes # and so on this function attempts to correct this
#' 
#' @param names_os_df column names from Open specimen data
#' @importFrom stringr str_trim str_split
#' @importFrom janitor make_clean_names
#' @return A character vector of names
#' 
#' @export
make_clean_os_names <- function(names_os_df){
   
   
  nms_break = make_clean_names(names_os_df) %>%
    str_trim

  
  split_nms <- lapply(nms_break,  str_split, "_")
  
  new_names <- vector(mode = "character",
                      length = length(nms_break))
  
  
  
  for(i in 1:length(split_nms)){
    
    this_s = split_nms[[i]] %>% unlist()
    tru_same = this_s[1] == this_s[2]
    
    if(tru_same& length(this_s) >= 2){
      
      this_s = this_s[-1]
    }
    
    this_s = paste0(this_s, collapse = "_")
    new_names[i] = this_s
  }
  
  
  new_names
}
```
  
```{r example-make_clean_os_names}

nms_os <- c("Participant_PPID", "Visit_Visit Site",
            "Visit_Name", "Visit_Event Label", 
            "Specimen_Specimen Label",
            "Specimen_Type", "Specimen_Lineage", "Specimen_Barcode", 
            "Specimen_Container Name", "Specimen_Container Position", 
            "Specimen_Requirement Name", "Collection Protocol_Short Title")

make_clean_os_names(nms_os)
```
  
```{r tests-make_clean_os_names}
test_that("del_repeat_os_names works", {
  expect_true(inherits(make_clean_os_names, "function")) 
})
```
  
# append_check_col
    
```{r function-append_check_col}
#' Append excel if condition
#' @description
#' usually we usually add a true false column to check if the shipped barcode is 
#' the barcode/specimen label  we selected. This function does exactly that it combines
#' OS data set and selected 
#' @param selected_samples A data frame from findBiobankR::selected_aliquots_df. If this is null please ensure that
#' os data set contains only column to send 
#' @param os_position This a data set that comes from open specimen
#' @param join_by_col column names in 
#' @importFrom utils object.size
#' @return A data.table with a checked column 
#' 
#' @export

# nms_new_pos <- c( "Specimen_Type", "Specimen_Requirement Name", 
#                   "Specimen_Specimen Label", "Specimen_Barcode", "Specimen_Container Name", 
#                   "Specimen_Container Position", "Scanned_barcode")
# 
# nms_old_pos <- c( "specimen_type", "specimen_requirement_name", 
#                   "specimen_label", "specimen_barcode", "specimen_container_name", 
#                   "specimen_container_position", "scanned_barcode")


append_check_col <- function(selected_samples = NULL,
                             os_position,
                             ppid_col = "Participant_PPID",
                             specimen_id_col = "specimen_label",
                             os_required_cols = c("Specimen_Specimen Label",
                                                  "Specimen_Type", "Specimen_Requirement Name", 
                                                  "Specimen_Barcode","Specimen_Container Name", 
                                                  "Specimen_Container Position"),
                             scanned_bar_code_col = "Scanned_barcode"){
  
  
  join_by_col = c(ppid_col, specimen_id_col)
  object_size = object.size(os_position)
  os_position[, (scanned_bar_code_col) := ""]
  nms_os = names(os_position)
  #nms_os = nms_os[nms_os %in% join_by_col]
  nms_os_c = make_clean_os_names(nms_os)
  
  setnames(os_position, old = nms_os, new = nms_os_c)
  
  join_by_col_neg = join_by_col[join_by_col %in% os_required_cols]
  required_cols = c(os_required_cols, 
                    scanned_bar_code_col) %>%
    unique()
  
  nms_old_pos = make_clean_os_names(required_cols)
  
  if(isFALSE(is.null(selected_samples))){
    
    os_selected <- merge(selected_samples,
                         os_position, 
                         by = join_by_col)
    
  }else{
    
    os_selected = os_position
    
  }
  
  
  if(isFALSE(all(nms_old_pos %in% nms_os_c))){
    
    nms_missing = nms_old_pos[!nms_old_pos %in% nms_os_c] %>%
      paste0(collapse = ",")
    msg = sprintf("The following required column names were not found %s", nms_missing)
    stop(msg)
    
  }
  
  
  #os_selected[, scanned_barcode := ""]
  nms_old_pos_2 <- c(ppid_col, nms_old_pos) %>% unique()
  os_selected <- os_selected[, ..nms_old_pos]
  os_selected[, specimen_barcode := gsub("^0","", specimen_barcode) ]
  os_selected[, specimen_barcode := paste0("0", specimen_barcode) ]
  nms_f <- names(os_selected)
  
  barcode_id <- which(nms_f == "specimen_barcode")
  scanned_id <- which(nms_f == "scanned_barcode")
  barcode_letter <- LETTERS[barcode_id]
  scanned_barcode_letter <- LETTERS[scanned_id]
  n_rows = 1:nrow(os_selected)
  excel_rows = n_rows+1
  barcode_rows <- paste0(barcode_letter, excel_rows)
  scanned_barcode_rows <- paste0(scanned_barcode_letter, excel_rows)
  os_selected[, checked :=paste0("IF(", barcode_rows,"=",scanned_barcode_rows,",1", ", 0",")" ) ]
  
  
  os_selected[, specimen_barcode := fifelse(specimen_barcode == "0", specimen_label,specimen_barcode ) ]
  
  setnames(os_selected, nms_old_pos, required_cols)
  
  class(os_selected$checked) <- c(class(os_selected$checked), "formula")
  
  os_selected
}
```



```{r example-append_check_col}

library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
#data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


clin_specs[, serum_aliquot := select_one_aliquot(NP_labels_serum, aliquot_number = 1 )]
clin_specs[, plasma_aliquot := select_one_aliquot(NP_labels_plasma, aliquot_number= 1 )]

# or tidyverse way

selected_samples <- selected_aliquots_df(clin_specs,
                                         aliquot_cols = c("serum_aliquot","plasma_aliquot"),
                                         ppid_col = "ppid")

df_send <- append_check_col(selected_samples = selected_samples,
                            os_position = tb_specimen_df,
                            ppid_col = "ppid",
                            specimen_id_col = "specimen_label")


```
  
```{r tests-append_check_col}
test_that("append_check_col works", {
  expect_true(inherits(append_check_col, "function")) 
})
```
  

```{r development-load}
  # Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```
  
  
  
  
```{r development-inflate, eval=FALSE}
  # Run but keep eval=FALSE to avoid infinite loop
  # Execute in the console directly
fusen::inflate(flat_file = "dev/sample_selections.Rmd",
               vignette_name = "sample-selections-vignette")
```
  
  

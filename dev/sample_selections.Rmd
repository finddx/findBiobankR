---
title: "Sample Selections"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->


# convert_os_df_to_wide 

```{r function-convert_os_df_to_wide }



#' Convert  OS data to wide
#' 
#' Convert OS data to wide and merge with clinical data
#' 
#' @param clinical_df A data frame with clinical data at Find typically from Open Clinica.
#' @param specimen_df A data frame with specimen data at Find generally Open Specimen.
#' @param os_aliquot_names A vector of the aliquot names that you want to use. 
#' @param join_by_col A column used to merge clinical data and specimen data
#' @param join_function A function in char to join with. Recommended to use
#'  dplyr merge function eg left_join, inner_join etc. Recommended to load dplyr 
#' @param specimen_col The column containing specimen names.
#'  At find usually Specimen Requirement name
#' @param clinical_vars A vector of clinical variables.
#'  Ideally variables that usually describe patient characteristics eg sex, 
#'  disease information etc
#' @param specimen_label_col Column containing specimen IDS in Open Specimen this is 
#'  specimen label
#' @importFrom janitor make_clean_names
#' @importFrom data.table setnames setDT 
#' @importFrom purrr reduce
#' @return A wide data frame with one row per participant and one column for
#'   each aliquot name and the number of aliquots and the specimen labels for
#'   that aliquot.
#'
#' @export

convert_os_df_to_wide <- function(clinical_df,
                                  specimen_df, 
                                  join_by_col,
                                  specimen_col,
                                  specimen_label_col,
                                  clinical_vars = NULL ,
                                  os_aliquot_names,
                                  join_function = "left_join") {
  
  # Check if input data frames are provided
  if (is.null(clinical_df) || is.null(specimen_df)) {
    stop("Input data frames 'clinical_df' and 'specimen_df' are required.")
  }
  
  # Check if join_by_col and specimen_col are present in the data frames
  if (!(join_by_col %in% names(clinical_df)) || !(join_by_col %in% names(specimen_df))) {
    stop("The column 'join_by_col' does not exist in the data frames.")
  }
  
  if (!(specimen_col %in% names(specimen_df))) {
    stop("The column 'specimen_col' does not exist in the 'specimen_df' data frame.")
  }
  
  # Check if os_aliquot_names is provided
  if (length(os_aliquot_names) == 0) {
    stop("The 'os_aliquot_names' vector is empty.")
  }
  
  # Clean the aliquot names.
  os_aliquot_names_clean <- make_clean_names(os_aliquot_names)
  
  # Create a list of data frames, one for each aliquot name.
  list_dfs = vector(mode = "list",
                    length = length(os_aliquot_names))
  
  for (i in seq_along(os_aliquot_names)) {
    
    aliq_name = os_aliquot_names[i]
    
    aliq_col_name = os_aliquot_names_clean[i]
    
    no_aliquots = paste0("NP_aliqN_",
                         aliq_col_name)
    aliquots_spec_label = paste0("NP_labels_", 
                                 aliq_col_name)
    
    new_nms = c(no_aliquots, aliquots_spec_label)
    
    old_nms = c("NP_aliqN", "NP_labels")
    # calculate aliquot numbers and 
    
    aliquot_samples_df <- specimen_df[get(specimen_col) == aliq_name,
                                      list(NP_aliqN = .N,
                                        NP_labels = list(get(specimen_label_col))),
                                      by = join_by_col]
    
    
    setnames(aliquot_samples_df,
             old_nms, 
             new_nms)
    
    list_dfs[[i]] = aliquot_samples_df
    
  }
  ## function use to merge data frames
  join_function <- match.fun(join_function)
  # Combine the list of data frames into a single data frame.
  final_df <- list_dfs %>% 
    reduce(join_function,
           by = join_by_col)
  
  # Set the data frame as a data table.
  
  setDT(final_df)
  
  # select only the variables required from clinical data
  if(!is.null(clinical_vars)){
    
    clinical_vars = c(join_by_col, clinical_vars)
    
    clinical_df = clinical_df[, .SD, 
                              .SDcols = clinical_vars]
  }
   ## merge with clinical df
  final_df <- merge(clinical_df,
                    final_df,
                    by = join_by_col,
                    all.x = T)
  
  
  # Return the wide data frame.
  final_df
}
```



```{r example-convert_os_df_to_wide }
library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)

knitr::kable(clin_specs[1:10, ])
```





```{r tests-convert_os_df_to_wide }
test_that("convert_os_df_to_wide  works", {
  library(data.table)
  data("tb_data", package = "findBiobankR")
  setnames(tb_data, "ppid", "ppid2")
  data("tb_specimen_df", package = "findBiobankR")
  
  expect_error( convert_os_df_to_wide(clinical_df = tb_data,
                                      specimen_df = tb_specimen_df, 
                                      join_by_col = "ppid",
                                      specimen_col ="specimen_type" ,
                                      clinical_vars = clinical_cols ,
                                      os_aliquot_names = c("Serum", "Plasma")),
                regxp ="The column 'join_by_col' does not exist in the data frames." )
})
```



# select_one_aliquot


```{r function-select_one_aliquot}
#' Title Select One aliquot 
#' 
#' Description This function selects a specific aliquot label from a list of objects/ A list column 
#' @param x The input is a list column or a list of vectors 
#' @param aliquot_number The number indicating the position of the desired aliquot label. Defaults to 1.
#' @return A list of selected aliquot labels.
#' @return A vector
#' 
#' @export


select_one_aliquot <- function(x, aliquot_number = 1){
  
  # Check if x is a list
  if (!is.list(x)) {
    stop("Parameter 'x' must be a list.")
  }
  # Check if aliquot_number is numeric
  if (isFALSE(aliquot_number %%1==0 | aliquot_number > 0)) {
    stop("Parameter 'aliquot_number' must be a non negative integer.")
  }
  
  #a list to store the selected aliquot labels
  list_aliquots <- lapply(seq_along(x),function(z){
    
    zx = x[[z]]
    
    if(is.null(zx) ){
      
      ans = NA
      
    }else if(aliquot_number > length(zx)){
      
      warning("Subscript out of bounds returning NA")
      
      ans = NA
      
    }else{
      
      ans = zx[[aliquot_number]] %>% unlist()
    }
    
    ans
  })
  
  unlist(list_aliquots)
}
```




```{r example-select_one_aliquot}
library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                      specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)

##
clin_specs[, select_one_aliquot(NP_labels_serum)]

# or data table way
clin_specs[, serum_aliquot_dt := select_one_aliquot(NP_labels_serum)]
# or tidyverse way
clin_specs %>%
  mutate(serum_aliquot_dp := select_one_aliquot(NP_labels_serum))

knitr::kable(clin_specs[1:10, ])

samples_list <- list(c("TB0990100010101001", "TB0990100010101002", "TB0990100010101003"),
                     c("TB0990100020101001", "TB0990100020101002", "TB0990100020101003"), 
                     c("TB0990100030101001", "TB0990100030101002", "TB0990100030101003"),
                     c("TB0990100040101001", "TB0990100040101002", "TB0990100040101003"),
                     c("TB0990100050101001", "TB0990100050101002", "TB0990100050101003"
                     ))
select_one_aliquot(samples_list, aliquot_number = 2)
```






```{r tests-select_one_aliquot}
test_that("select_one_aliquot works", {
  
  samples_list <- list(c("TB0990100010101001", 
                         "TB0990100010101002",
                         "TB0990100010101003"))
  
  expect_warning(select_one_aliquot(samples_list, aliquot_number = 4),
                 regxp ="Subscript out of bounds returning NA" )
  expect_equal(select_one_aliquot(samples_list, aliquot_number = 1),"TB0990100010101001" )
})
```


# select_many_aliquots


```{r function-select_many_aliquots}
#' Title Select many aliquots 
#'
#' Description Selects multiple aliquots labels from a list of lists.
#'
#' @param x A list of lists containing aliquot labels.
#' @param aliquots The number of aliquots to select.
#'
#' @return A list of vectors, each containing the selected aliquot labels.
#'
#' @export

select_many_aliquots <- function(x, aliquots) {
  
  if (aliquots <= 0){
    stop("Number of aliquots must be specified and greater than 0")
  }
  
  aliquot_pos <- seq_len(aliquots)
  
  nms <- paste0("aliquots", aliquot_pos)
  
  list_aliquots <- vector(mode = "list",
                          length = aliquots)
  
  list_aliquots <- lapply(seq_along(aliquot_pos), function(i){
    
    aliquot_label_i <- select_one_aliquot(x, aliquot_number = i)
    aliquot_label_i
    
    
    
  }
  )
  names(list_aliquots) <- nms
  
  list_aliquots
}
```


```{r example-select_many_aliquots}

samples_list <- list(c("TB0990100010101001", "TB0990100010101002", "TB0990100010101003"),
                     c("TB0990100020101001", "TB0990100020101002", "TB0990100020101003"), 
                     c("TB0990100030101001", "TB0990100030101002", "TB0990100030101003"),
                     c("TB0990100040101001", "TB0990100040101002", "TB0990100040101003"),
                     c("TB0990100050101001", "TB0990100050101002", "TB0990100050101003"
                     ))

## Select two aliquots per patient
aliquots_selected <- select_many_aliquots(samples_list, 
                                          aliquots = 2)

aliquots_selected
```


```{r tests-select_many_aliquots}

library(testthat)

# Define test cases
test_that("select_many_aliquots returns correct aliquots", {
  samples_list <- list(
    c("TB0990100010101001", "TB0990100010101002", "TB0990100010101003"),
    c("TB0990100020101001", "TB0990100020101002", "TB0990100020101003"),
    c("TB0990100030101001", "TB0990100030101002", "TB0990100030101003"),
    c("TB0990100040101001", "TB0990100040101002", "TB0990100040101003"),
    c("TB0990100050101001", "TB0990100050101002", "TB0990100050101003")
  )
  
  # Test case 1
  expected_result_1 <- list(
   aliquots1 =  c("TB0990100010101001", "TB0990100020101001", 
                  "TB0990100030101001", "TB0990100040101001", 
                  "TB0990100050101001"),
    aliquots2 = c("TB0990100010101002", "TB0990100020101002",
                  "TB0990100030101002", "TB0990100040101002",
                  "TB0990100050101002"),
   
   aliquots3 =  c("TB0990100010101003", "TB0990100020101003",
                  "TB0990100030101003", "TB0990100040101003", 
                  "TB0990100050101003"))
   
    result_1 <- select_many_aliquots(samples_list, 3)
    expect_equal(result_1, expected_result_1)
    
    # Test case 2
    expected_result_2 <- list(
      aliquots1 = c("TB0990100010101001", "TB0990100020101001", 
                    "TB0990100030101001", "TB0990100040101001",
                    "TB0990100050101001"
))
    result_2 <- select_many_aliquots(samples_list, 1)
    
    expect_equal(result_2, expected_result_2)
    
    
    # Test case 3
    expect_error(select_many_aliquots(samples_list, 0), 
                 regxp = "Number of aliquots must be specified and greater than 0")
})
  
  
```
  
 # select_patients_per_group
    
```{r function-select_patients_per_group}
#' Select patients per group
#' For sample selections often this is based on patient groups and required number of patients maybe be different per patient group. This function helps with this selection 
#' @param df A data.frame with clinical data and number of aliquots per patient column 
#' @param patient_group_col The column name with patient characterization 
#' @param patient_groups A vector of patient group. This names should be categories in patient_group_col
#' @param number_per_group A vector same length indicating how many patient to select per group 
#' @param sort_cols column(s) names that should be used to sort your data frame. We prefer to select patients with higher of aliquots 
#' @importFrom data.table setDT rbindlist setorderv
#' @return data.table 
#' 
#' @export
select_patients_per_group <- function(df, 
                            patient_group_col,
                            patient_groups,
                            number_per_group,
                            sort_cols
                            ){
   # Check that the number_per_group vector is the same length as the patient_groups vector
  if (length(number_per_group) != length(patient_groups)) {
    stop("The number_per_group vector is not the same length as the patient_groups vector")
  }
  
  setDT(df)
  list_selected = vector(mode = "list", 
                         length = length(patient_groups))
  
  for (i in seq_along(patient_groups)) {
    
    patient_grp = patient_groups[i]
    no_i = number_per_group[i]
    df1 = df[get(patient_group_col)  ==patient_grp ]
    if(isFALSE(nrow(df1) >= no_i)){
      
      stop_mess = glue::glue("Patient group {patient_grp} has insuficient number of participants for \\
                          group, The number of participant required \\
                          are {no_i}, the number available is {nrow(df1)}")
      stop(stop_mess)
    }
    setorderv(df1,cols = sort_cols, order = -1L)
    
    df1 = df1[1:no_i]
    list_selected[[i]] = df1
    
  }
  df_final = rbindlist(list_selected)
  df_final
}
```



```{r example-select_patients_per_group}

library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


## select 2 patients per group 
patient_groups  <- c("TB, Neg", "TB, Pos")
number_per_group  <- c(2, 2)
sort_cols = "NP_aliqN_serum"
clin_specs_2 <- select_patients_per_group(df = clin_specs, 
                                          patient_group_col = "tb_group",
                                          patient_groups = patient_groups,
                                          number_per_group = number_per_group,
                                          sort_cols = sort_cols)


```

 
```{r tests-select_patients_per_group}

test_that("select_patients_per_group works", {
  expect_true(inherits(select_patients_per_group, "function")) 
})


```

# selected_aliquots_df
    
```{r function-selected_aliquots_df}
#' Create a data frame with selected aliquots in long format
#'
#' @description
#' This function is used in conjunction from other findBiobankR package. It accepts an a data drame/data.table 
#' with selected aliquots as a column 
#' @seealso findBiobank::select_one_aliquot
#' @param clin_specs A data from with the selected aliquots as column
#' @param aliquot_cols Column names of the selected aliquots in `clin_specs` data frame
#' @param ppid_col Participant ID column 
#' @param aliquot_name_col The name of the variable name after data.table::melt
#' @param spec_label_col The name of the value name after data.table::melt
#' @importFrom stringr str_replace_all str_trim
#' @importFrom data.table melt setDT
#' @return a data.table with `ppid, specimen_label_col` columns 
#' 
#' @export
#' 
selected_aliquots_df <- function(clin_specs,
                                 aliquot_cols,
                                 ppid_col = "Participant_PPID",
                                 aliquot_name_col = "aliquot_name",
                                 spec_label_col = "specimen_label"){
  
  
  data_name = deparse(substitute(clin_specs))
  
  if(isFALSE(inherits(clin_specs, "data.table"))){
    
    msg = sprintf("%s is a data.frame converting this to data.table", data_name)
    message(msg)
  }
  nms_selected_labels <- c(ppid_col,aliquot_cols)
  
  urien23selected <- clin_specs[, .SD, .SDcols = nms_selected_labels]
  
  
  
  urien23selected_m <- melt(urien23selected, 
                            id.vars =ppid_col,
                            variable.name = aliquot_name_col,
                            value.name = spec_label_col)
  
  urien23selected_m[, (aliquot_name_col) := NULL]
  
  urien23selected_m <- urien23selected_m[!is.na(get(spec_label_col))]
  
  urien23selected_m <- unique(urien23selected_m,
                              by ="specimen_label")
  urien23selected_m[, (spec_label_col) := str_replace_all(get(spec_label_col), '"|\\)|\\(|^c', '')]
  urien23selected_m[, (spec_label_col) := str_trim(get(spec_label_col))]
  urien23selected_m
}
```
  
```{r example-selected_aliquots_df}

library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                      specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


clin_specs[, serum_aliquot := select_one_aliquot(NP_labels_serum, aliquot_number = 1 )]
clin_specs[, plasma_aliquot := select_one_aliquot(NP_labels_plasma, aliquot_number= 1 )]

## prepare data set
selected_aliquots_df(clin_specs,
                     aliquot_cols = c("serum_aliquot","plasma_aliquot"),
                     ppid_col = "ppid")
```
  
```{r tests-selected_aliquots_df}
test_that("selected_aliquots_df works", {
  expect_true(inherits(selected_aliquots_df, "function")) 
})
```

# make_clean_os_names
    
```{r function-make_clean_os_names}
#' Clean Open Specimen Names
#' 
#' @description
#' Data set from Open specimen normally come with very programming unfriendly column
#' names with repeat suffixes # and so on this function attempts to correct this
#' 
#' @param names_os_df column names from Open specimen data or Open Specimen data.frame
#' @importFrom stringr str_trim str_split
#' @importFrom janitor make_clean_names
#' @return A character vector of names or data.frame
#' @export
make_clean_os_names <- function(names_os_df){
  
  UseMethod("make_clean_os_names", names_os_df)
  
  }

#' @export
make_clean_os_names.default <- function(names_os_df){
  
  stopifnot("names_os_df should be a character vector"=is.character(names_os_df))
  
  nms_break = make_clean_names(names_os_df) %>%
    str_trim
  
  
  split_nms <- lapply(nms_break,  str_split, "_")
  
  new_names <- vector(mode = "character",
                      length = length(nms_break))
  
  
  
  for(i in 1:length(split_nms)){
    
    this_s = split_nms[[i]] %>% unlist()
    tru_same = this_s[1] == this_s[2]
    
    if(tru_same& length(this_s) >= 2){
      
      this_s = this_s[-1]
    }
    
    this_s = paste0(this_s, collapse = "_")
    new_names[i] = this_s
  }
  
  
  new_names
}


#' @export

make_clean_os_names.data.frame <- function(names_os_df){
  
  nms = names(names_os_df)
  nms_new = make_clean_os_names(nms)
  setnames(names_os_df, nms, nms_new )
}

```
  
```{r example-make_clean_os_names}

nms_os <- c("Participant_PPID", "Visit_Visit Site",
            "Visit_Name", "Visit_Event Label", 
            "Specimen_Specimen Label",
            "Specimen_Type", "Specimen_Lineage", "Specimen_Barcode", 
            "Specimen_Container Name", "Specimen_Container Position", 
            "Specimen_Requirement Name", "Collection Protocol_Short Title")

make_clean_os_names(nms_os)
```
  
```{r tests-make_clean_os_names}
test_that("del_repeat_os_names works", {
  expect_true(inherits(make_clean_os_names, "function")) 
})
```

# read_os_data
    
```{r function-read_os_data}
#' Read Open Specimen data.frame in R
#' 
#' @description
#' A function to read Open Specimen data. The need comes from the fact that this function standadizes names
#' 
#' @param path_name Path to OS data
#' @param header_true Whether the file has a header defaults to false
#' @param ... Other parameters taken by data.table::fread
#' @importFrom data.table fread setnames
#' @return data.table
#' 
#' @export
read_os_data <- function(path_name,
                         header_true = FALSE,
                         ...){
  
  df = fread(path_name,
             sep = ",",
             header = header_true,
             fill = T, ...)
  
  empty_row = which(grepl("^$", df$V1))
  header_row = empty_row + 1
  
  new_nms = df[header_row, ] %>%
    as.character() %>%
    make_clean_os_names()
  
  old_nms = names(df)
  df <- df[-c(1:header_row)]
  setnames(df, old = old_nms,
           new = new_nms)
  df
  
}
```
  
```{r example-read_os_data}
tb_specs <- system.file("extdata", "tb_specs.csv",
                          package = "findBiobankR")
read_os_data(path_name = tb_specs)
```
  
```{r tests-read_os_data}
test_that("read_os_data works", {
  expect_true(inherits(read_os_data, "function")) 
})
```
  
  
# append_check_col
    
```{r function-append_check_col}
#' Append excel if condition
#' @description
#' usually we usually add a true false column to check if the shipped barcode is 
#' the barcode/specimen label  we selected. This function does exactly that it combines
#' OS data set and selected 
#' @param selected_samples A data frame from findBiobankR::selected_aliquots_df. If this is null please ensure that
#' os data set contains only column to send 
#' @param os_position This a data set that comes from open specimen
#' @param ppid_col Participant id column. 
#' @param specimen_id_col Specimen ID column name
#' @param os_required_cols Column names required to send a list to a requester
#' @param scanned_bar_code_col The name of the barcode column name with retrieved specimens 
#' @importFrom utils object.size
#' @importFrom data.table fifelse setDT
#' @return A data.table with a checked column 
#' 
#' @export

# nms_new_pos <- c( "Specimen_Type", "Specimen_Requirement Name", 
#                   "Specimen_Specimen Label", "Specimen_Barcode", "Specimen_Container Name", 
#                   "Specimen_Container Position", "Scanned_barcode")
# 
# nms_old_pos <- c( "specimen_type", "specimen_requirement_name", 
#                   "specimen_label", "specimen_barcode", "specimen_container_name", 
#                   "specimen_container_position", "scanned_barcode")

append_check_col <- function(selected_samples,
                             os_position,
                             ppid_col = "Participant_PPID",
                             specimen_id_col = "specimen_label",
                             os_required_cols = c("Participant_PPID",
                                                  "Specimen_Specimen Label",
                                                  "Specimen_Type", 
                                                  "Specimen_Requirement Name", 
                                                  "Specimen_Barcode",
                                                  "Specimen_Container Name", 
                                                  "Specimen_Container Position",
                                                  "Scanned_barcode"),
                             scanned_bar_code_col = "Scanned_barcode"){
  
  
  join_by_col = c(ppid_col, specimen_id_col)
  object_size = object.size(os_position)
  os_position[, (scanned_bar_code_col) := ""]
  
  
  nms_old_pos = make_clean_os_names(os_required_cols)
  
  if(isFALSE(is.null(selected_samples))){
    
    os_selected <- merge(selected_samples,
                         os_position, 
                         by = join_by_col)
    
  }else{
    
    os_selected = os_position
    
  }
  
  make_clean_os_names(os_selected)
  
  nms_os_c = names(os_selected)
  
  if(isFALSE(all(nms_old_pos %in% nms_os_c))){
    
    nms_missing = nms_old_pos[!nms_old_pos %in% nms_os_c] %>%
      paste0(collapse = ",")
    msg = sprintf("The following required column names were not found %s", nms_missing)
    stop(msg)
    
  }
  
  setDT(os_selected)
  
  
  
  os_selected <- os_selected[, ..nms_old_pos]
  os_selected[, specimen_barcode := gsub("^0","", specimen_barcode) ]
  os_selected[, specimen_barcode := paste0("0", specimen_barcode) ]
  nms_f <- names(os_selected)
  
  barcode_id <- which(nms_f == "specimen_barcode")
  scanned_id <- which(nms_f == "scanned_barcode")
  barcode_letter <- LETTERS[barcode_id]
  scanned_barcode_letter <- LETTERS[scanned_id]
  n_rows = 1:nrow(os_selected)
  excel_rows = n_rows+1
  barcode_rows <- paste0(barcode_letter, excel_rows)
  scanned_barcode_rows <- paste0(scanned_barcode_letter, excel_rows)
  os_selected[, checked :=paste0("IF(", barcode_rows,"=",scanned_barcode_rows,",1", ", 0",")" ) ]
  
  
  os_selected[, specimen_barcode := fifelse(specimen_barcode == "0", specimen_label,specimen_barcode ) ]
  
  setnames(os_selected, nms_old_pos, os_required_cols)
  
  class(os_selected$checked) <- c(class(os_selected$checked), "formula")
  
  os_selected
}
```



```{r example-append_check_col}

library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
#data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


clin_specs[, serum_aliquot := select_one_aliquot(NP_labels_serum, aliquot_number = 1 )]
clin_specs[, plasma_aliquot := select_one_aliquot(NP_labels_plasma, aliquot_number= 1 )]

# or tidyverse way

selected_samples <- selected_aliquots_df(clin_specs,
                                         aliquot_cols = c("serum_aliquot","plasma_aliquot"),
                                         ppid_col = "ppid")

df_send <- append_check_col(selected_samples = selected_samples,
                            os_position = tb_specimen_df,
                            ppid_col = "ppid",
                            specimen_id_col = "specimen_label",
                            os_required_cols = c("ppid",
                                                 "Specimen_Specimen Label",
                                                 "Specimen_Type", 
                                                 "Specimen_Requirement Name", 
                                                 "Specimen_Barcode",
                                                 "Specimen_Container Name", 
                                                 "Specimen_Container Position",
                                                 "Scanned_barcode"))

df_send
```

```{r tests-append_check_col}
test_that("append_check_col works", {
  expect_true(inherits(append_check_col, "function")) 
})
```
  
  
  
# process_save_selected_aliquots
    
```{r function-process_save_selected_aliquots}
#' Save selected aliquots as excel
#' 
#' Save the selected aliquots with the check column data set in excel 
#'
#' @param file_path The location to save your file as .xlsx
#' @param save_file Logical to save file in 
#' @param ...  arguments taken by findBiobankR::append_check_col
#' @importFrom tools file_ext
#' @importFrom openxlsx write.xlsx
#' @return A data frame silently writes a file to given path
#' 
#' @export

process_save_selected_aliquots <- function(file_path = NULL, save_file= FALSE, ...){
  
  if(!is.null(file_path)){
    
    stopifnot( "save_file option should be TRUE when file_path is provided" = isTRUE(save_file))
    dir_name = dirname(file_path)
    
    if(isFALSE(dir.exists(dir_name))) {
      
      stop(sprintf("The folder (%s) does not exist, Please check you file path", dir_name))
    } 
    
    file_extension = file_ext(file_path)
    
    if(file_extension != "xlsx"){
      
      stop("The extension of the file is not an excel file")
      
    }
    
    
  }
  
  
  selected_aliquots <- append_check_col(...)
  
  
  
  
  stopifnot("save_file option should be logical" = isTRUE(is.logical(save_file)))
  
  if(isFALSE(save_file)){
    
    message(sprintf("File not save. if you want to save please provide arguments file_path and save_file should be true"))
   
  }
  
  if(save_file){
    message(sprintf("Saving the selected data frame in %s", file_path))
    write.xlsx(selected_aliquots,
               file = file_path ) 
  }
  
  return(selected_aliquots)
  
}
```
  
```{r example-process_save_selected_aliquots}

library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
#data("tb_specimen_df", package = "findBiobankR")

# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


clin_specs[, serum_aliquot := select_one_aliquot(NP_labels_serum, aliquot_number = 1 )]
clin_specs[, plasma_aliquot := select_one_aliquot(NP_labels_plasma, aliquot_number= 1 )]


selected_samples <- selected_aliquots_df(clin_specs,
                                         aliquot_cols = c("serum_aliquot","plasma_aliquot"),
                                         ppid_col = "ppid")

path_name <- tempfile(pattern = "create_work_book") %>%
  normalizePath(winslash = "/")

dir.create(path_name)

# create file name
path_name <- file.path(path_name, "aliquots.xlsx")

process_save_selected_aliquots(file_path = path_name,
                               save_file= TRUE,
                               selected_samples = selected_samples,
                               os_position = tb_specimen_df,
                               ppid_col = "ppid",
                               specimen_id_col = "specimen_label",
                               os_required_cols = c("ppid",
                                                    "Specimen_Specimen Label",
                                                    "Specimen_Type",
                                                    "Specimen_Requirement Name", 
                                                    "Specimen_Barcode",
                                                    "Specimen_Container Name", 
                                                    "Specimen_Container Position",
                                                    "Scanned_barcode"))

```
  
```{r tests-process_save_selected_aliquots}
test_that("process_save_selected_aliquots works", {
  expect_true(inherits(process_save_selected_aliquots, "function")) 
})
```
  
  
# create_save_workbook
    
```{r function-create_save_workbook}
#' Save a list of data frames to excel file
#' 
#' Given a list of data.frames save this 

#' @param list_of_dfs A list of data frames to write to the workbook.
#' @param path_name The path to the Excel workbook to create.
#' @param sheet_names A character vector of names for the sheets in the workbook.
#'
#' @return The workbook object.
#'
#' @importFrom openxlsx createWorkbook addWorksheet writeData saveWorkbook
#' @importFrom data.table setDF
#'
#' @export
create_save_workbook  <- function(list_of_dfs, path_name, sheet_names) {
  
  # Check the input arguments for validity
  stopifnot(is.list(list_of_dfs) && all(sapply(list_of_dfs, is.data.frame)))
  stopifnot(is.character(sheet_names))
  stopifnot("Directory provided does not exists"= dir.exists(dirname(path_name)))
  stopifnot("Number of sheets is not equal to number of data frames"= length(list_of_dfs) ==length(sheet_names))
  # Create the workbook
  
  wb <- createWorkbook()
  
  # Write the data frames to the workbook
  lapply(seq_along(list_of_dfs), function(i) {
    
    df <- list_of_dfs[[i]]
    sheet_i <- sheet_names[i]
    setDF(df)
    addWorksheet(wb, sheet_i)
    writeData(wb, sheet_i, df, startCol = 1, startRow = 1)
    
  })
  
  # Save the workbook
  saveWorkbook(wb, file = path_name)
  
  # Return the workbook object
  invisible(wb)
}
```
  
```{r example-create_save_workbook}

df1 <- data.frame(x = 1:10, y = 11:20)
df2 <- data.frame(a = letters[1:5], b = letters[6:10])
list_of_dfs <- list(df1, df2)

# Specify the names of the sheets
sheet_names <- c("Sheet1", "Sheet2")

#create temporary folder 
path_name <- tempfile(pattern = "create_work_book") %>%
  normalizePath(winslash = "/")

dir.create(path_name)

# create file name
file_name <- file.path(path_name, "test.xlsx")

# Create the workbook
create_save_workbook(list_of_dfs,
                     path_name = file_name, 
                     sheet_names)
file.remove(file_name)
unlink(path_name)

```
  
```{r tests-create_save_workbook}
test_that("create_save_workbook works", {
  expect_true(inherits(create_save_workbook, "function")) 
})
```


  
  
# gen_clinical_data
    
```{r function-gen_clinical_data}
#' Provide a list of dfs with clinical samples and dictionary data set
#' 
#' This function processes clinical data set, lab data set and a dictionary. 
#' 
#' @param clinical_data Clinical data set
#' @param clinical_cols  Clinical column names to cinclude 
#' @param selected_samples_df aliquots to send ideally a data.frame from  findBiobankR::process_save_selected_aliquots or lab data specimen data
#' @param specimen_cols Required columns from specimen data frame 
#' @param dictionary Dictionary to provide to sample requester 
#' @param ppid_col Participant id column A column that should be in `selected_samples_df` and `clinical_data` for merging 
#' @param dict_variable dictionary variable name containing clinical cols 
#' @param additional_data and Additiona data frame that should contain `ppid_col`
#' @return A list of data.frames 
#' @export
gen_clinical_data <- function(clinical_data,
                              clinical_cols,
                              dictionary,
                              selected_samples_df,
                              ppid_col,
                              dict_variable,
                              specimen_cols = c("Participant_PPID", "Specimen_Barcode", "Specimen_Specimen Label"),
                              additional_data = NULL ){
  
  setDT(clinical_data)
  setDT(selected_samples_df)
  setDT(selected_samples_df)
  setDT(dictionary)
  nms_clinical = names(clinical_data)
  nms_selected_samples = names(selected_samples_df)
  
  if(isFALSE(all(specimen_cols %in% nms_selected_samples))){
    
    nms_missing = specimen_cols[!specimen_cols %in% nms_selected_samples] %>%
      paste0(collapse = ",")
    msg = sprintf("The following required column names were not found  %s in selected_samples_df", nms_missing)
    stop(msg)
    
  }
  
  if(isFALSE(all(nms_clinical %in% nms_clinical))){
    
    nms_missing = nms_clinical[!nms_clinical %in% nms_clinical] %>%
      paste0(collapse = ",")
    msg = sprintf("The following required column name %s were not found in clinical_data", nms_missing)
    stop(msg)
    
  }
  
  if (!(ppid_col %in%nms_clinical ) || !(ppid_col %in% nms_selected_samples)) {
    stop("ppid_col is not present in both clinical_data and selected_samples_df")
    
    
    
  }
  clinical_data <- merge(selected_samples_df,
                         clinical_data, by = ppid_col ) 
  
  if(isFALSE(is.null(additional_data))){
    
    nms_additional = names(additional_data)
    
    if (!(ppid_col %in%nms_additional)) {
      
      stop("ppid_col is not present in the additional data set")
    }
    clinical_data <- merge(additional_data,
                           clinical_data, by = ppid_col ) 
    
    
  }else{
    
    nms_additional = NULL
  }
  
  all_cols = c(nms_additional,
               ppid_col, 
               specimen_cols,
               clinical_cols) %>% unique()
  
  clinical_data = clinical_data[, ..all_cols]
  date_cols = clinical_data[, .SD, .SDcols = lubridate::is.Date] %>% names()
  time_cols = clinical_data[, .SD, .SDcols = lubridate::is.timepoint] %>% names()
  date_time_cols = c(date_cols, time_cols)
  
  if(length(date_time_cols) == 0){
    
    clinical_data[, (date_time_cols) := lapply(.SD, as.character), .SDcols = date_time_cols]
  }
  
  
  clinical_data[, (all_cols) := lapply(.SD, 
                                       function(x) ifelse(x %in% c("Missing", "", "NA"),
                                                          NA, x)), 
                .SDcols = all_cols]
  
  #clinical_data[clinical_data == "Missing"] = NA
  clinical_data <- rm_all_na_col(clinical_data)
  nms_clinical_data <- names(clinical_data)
  dictionary <- dictionary[get(dict_variable) %in%nms_clinical_data ]
  
  list(clinical_data = clinical_data, 
       dictionary = dictionary,
       samples_list = selected_samples_df )
}



```
  
```{r example-gen_clinical_data}
library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")
data("tb_dictionary", package = "findBiobankR")
# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


clin_specs[1:4, serum_aliquot := select_one_aliquot(NP_labels_serum, aliquot_number = 1 )]
clin_specs[1:4, plasma_aliquot := select_one_aliquot(NP_labels_plasma, aliquot_number= 1 )]


selected_samples <- selected_aliquots_df(clin_specs,
                                         aliquot_cols = c("serum_aliquot","plasma_aliquot"),
                                         ppid_col = "ppid")

selected_samples_df <- process_save_selected_aliquots(file_path = NULL,
                               save_file= FALSE,
                               selected_samples = selected_samples,
                               os_position = tb_specimen_df,
                               ppid_col = "ppid",
                               specimen_id_col = "specimen_label",
                               os_required_cols = c("ppid",
                                                    "Specimen_Specimen Label",
                                                    "Specimen_Type",
                                                    "Specimen_Requirement Name", 
                                                    "Specimen_Barcode",
                                                    "Specimen_Container Name", 
                                                    "Specimen_Container Position",
                                                    "Scanned_barcode"))

gen_clinical_data(clinical_data = tb_data,
                  clinical_cols= clinical_cols,
                  dictionary = tb_dictionary,
                  selected_samples_df = selected_samples_df,
                  ppid_col = "ppid",
                  dict_variable = "variable_name",
                  specimen_cols = c("ppid", "Specimen_Specimen Label", "Specimen_Type"),
                  additional_data = NULL )

```
  
```{r tests-gen_clinical_data}
test_that("gen_clinical_data works", {
  expect_true(inherits(gen_clinical_data, "function")) 
})
```

# samples_distributed_summary
    
```{r function-samples_distributed_summary}
#' A summary of samples distributed
#' 
#' @description
#' This functions calculates a summary of distributed samples 
#' @param df Clinical data with selected samples 
#' @param unique_by_col Column name to calculate unique IDS 
#' @param wider_by_col column to convert long data.frame to wide data.frame
#' @param group_by_col column names to group your data with and calculate frequencies 
#' @param save_file whether to save your file 
#' @param path_name File path to save your file
#' @param order_col Column to order your final summary 
#' @importFrom data.table setorderv setDT
#' @importFrom janitor adorn_totals
#' @importFrom tidyr pivot_wider
#' @return data.frame 
#' 
#' @export
samples_distributed_summary <- function(df,
                                        unique_by_col = "Participant_PPID",
                                        wider_by_col = "Specimen_Requirement Name",
                                        group_by_col = "tb_group",
                                        save_file = FALSE,
                                        path_name = NULL,
                                        order_col = "Total"){
  
  freq_val = "freq"
  
  grp_cols = c(group_by_col, wider_by_col)
  
  df1 =  unique(df, by = unique_by_col)
  
  part_no <- df1[, list("Number participants" = .N), by =group_by_col] %>%
    adorn_totals(where = c("row"))
  
  specs_no <- df[, list(freq= .N), by = grp_cols ] %>%
    
    pivot_wider(names_from ={{wider_by_col}}, 
                values_from = {{freq_val}} )  %>% 
    adorn_totals(where = c("col", "row"))
  
  
  setDT(specs_no)
  
  dff <- merge(part_no,
               specs_no,
               by = group_by_col)
  
  setorderv(dff,  order_col)
  
  if(save_file){
    
    if(is.null(path_name)){
      
      stop("please provide a path to save your file")
    }
    stopifnot("Directory provided does not exists"= dir.exists(dirname(path_name)))
    utils::write.csv(dff, file = path_name)
  }
  dff 
  
}
```
  
```{r example-samples_distributed_summary}
library(data.table)
library(dplyr)
data("tb_data", package = "findBiobankR")
data("tb_specimen_df", package = "findBiobankR")
data("tb_dictionary", package = "findBiobankR")
# required clinical cols
clinical_cols <- c("tb_group", "hiv_status", "sex", "country") 

clin_specs  <- convert_os_df_to_wide(clinical_df = tb_data,
                                     specimen_df = tb_specimen_df, 
                                     join_by_col = "ppid",
                                     specimen_col ="specimen_type" ,
                                     clinical_vars = clinical_cols ,
                                     specimen_label_col = "specimen_label",
                                     os_aliquot_names = c("Serum", "Plasma")
)


clin_specs[1:4, serum_aliquot := select_one_aliquot(NP_labels_serum, aliquot_number = 1 )]
clin_specs[1:4, plasma_aliquot := select_one_aliquot(NP_labels_plasma, aliquot_number= 1 )]


selected_samples <- selected_aliquots_df(clin_specs,
                                         aliquot_cols = c("serum_aliquot","plasma_aliquot"),
                                         ppid_col = "ppid")

selected_samples_df <- process_save_selected_aliquots(file_path = NULL,
                               save_file= FALSE,
                               selected_samples = selected_samples,
                               os_position = tb_specimen_df,
                               ppid_col = "ppid",
                               specimen_id_col = "specimen_label",
                               os_required_cols = c("ppid",
                                                    "Specimen_Specimen Label",
                                                    "Specimen_Type",
                                                    "Specimen_Requirement Name", 
                                                    "Specimen_Barcode",
                                                    "Specimen_Container Name", 
                                                    "Specimen_Container Position",
                                                    "Scanned_barcode"))

list_dfs <- gen_clinical_data(clinical_data = tb_data,
                  clinical_cols= clinical_cols,
                  dictionary = tb_dictionary,
                  selected_samples_df = selected_samples_df,
                  ppid_col = "ppid",
                  dict_variable = "variable_name",
                  specimen_cols = c("ppid", "Specimen_Specimen Label", "Specimen_Type"),
                  additional_data = NULL )

samples_distributed_summary(df =list_dfs$clinical_data ,
         unique_by_col = "ppid",
         wider_by_col =  "Specimen_Type",
         group_by_col = "tb_group",
         save_file = FALSE,
         path_name = NULL,
         order_col = "Total")
```
  
  
```{r tests-samples_distributed_summary}
test_that("samples_distributed_summary works", {
  expect_true(inherits(samples_distributed_summary, "function")) 
})
```
  

```{r development-load}
  # Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```
  
  
  
  
```{r development-inflate, eval=FALSE}
  # Run but keep eval=FALSE to avoid infinite loop
  # Execute in the console directly
fusen::inflate(flat_file = "dev/sample_selections.Rmd",
               vignette_name = "sample-selections-vignette")
```
  
  

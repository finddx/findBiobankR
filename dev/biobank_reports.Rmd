---
title: "flat_my_fun.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# data_table
    
```{r function-data_table}
#' data_table function
#'
#' This function creates a datatable from a data frame using the DT package.
#'
#' @param df The data frame to be displayed as a datatable.
#' @param pageLength The number of rows to display per page. Default is 50.
#' @param row_names Logical value indicating whether to display row names. Default is FALSE.
#' @param file_name The name of the file to be used for exporting data. 
#' @importFrom DT datatable
#' @return An interactive data table of class DT
#' @export
data_table <- function(df, pageLength = 50, 
                       row_names = FALSE,
                       file_name = "output_file") {
    
    stopifnot("Data frame must be provide"=!missing(df))
    
    if(isFALSE(inherits(df, "data.frame"))){
        stop("df must be a data.frame")
    }
    

    n_col <- ncol(df) - 1
    datatable(df,
              rownames = row_names,
              extensions = 'Buttons',
              #style = "bootstrap4",
              #class = 'cell-border stripe',
              options = list(
                  scrollX = TRUE,
                  pageLength = pageLength,
                  dom = 'Blfrtip',
                  buttons = list(
                      list(extend = 'copy', filename = file_name),
                      list(extend = 'csv', filename = file_name),
                      list(extend = 'excel', filename = file_name),
                      list(extend = 'pdf', filename = file_name)
                  ),
                  columnDefs = list(
                      list(className = 'dt-center', targets = 0:n_col)
                  )
              )
    )
}

```
  
  
```{r example-data_table}
 data("iris")
df = iris[1:10,]

data_table(df, 
           file_name = "iris_sub_df")
```
 
  
```{r tests-data_table}
test_that("data_table displays datatable correctly", {
  df <- iris[1:10,]
  output <- data_table(df, pageLength = 10, file_name = "")
  
  # Test if the output contains expected elements
  expect_true(inherits(output, "datatables"))
  
  expect_error(data_table(df = c(1,2,3)),
               regexp ="df must be a data.frame")

})

```
  
# read_multiple_sheets
    
```{r function-read_multiple_sheets}
#' Read Sheets  From excel workbook
#' 
#' Read Files From excel workbook 
#' 
#' @param file_path path to file  
#' @param ... Other parameters from read excel function 
#' @return returns a list of data frames 
#' @importFrom readxl read_excel excel_sheets
#' @importFrom data.table setDT 
#' @importFrom purrr  set_names possibly
#' @importFrom tools file_ext
#' @importFrom janitor make_clean_names
#' @return A list of data frames 
#' 
#' @export
#'
read_multiple_sheets <- function(file_path, ...){
    
    
    if(isFALSE(file.exists(file_path))) {
        
        stop("The file provided doesn't exists, Check path")
    } 
    
    file_extension = file_ext(file_path)
    
    if(file_extension != "xlsx"){
        
        stop("The extension of the file is not an excel file")
        
    }
    
    xl_sheets <- excel_sheets(file_path)
    
    xl_sheets_clean <- make_clean_names(xl_sheets)
    
    possi_excel <- possibly(read_excel, otherwise = NULL)
    
    list_of_files <- lapply(xl_sheets, function(x){
        
        possi_excel(file_path, sheet = x, ...) %>%

      setDT()
        
    })%>% set_names(xl_sheets_clean)
    
   
    
}
```
  
```{r example-read_multiple_sheets}
iris_species <- system.file("extdata", "iris_species.xlsx",
                          package = "findBiobankR")

iris_list <- read_multiple_sheets(file_path  = iris_species ) %>% 
  lapply(head, 4)
iris_list
```
  
```{r tests-read_multiple_sheets}
# Test if the function throws an error when the file doesn't exist
test_that("Error is thrown when file doesn't exist", {
    expect_error(read_multiple_sheets("non_existent_file.xlsx"), 
                 "The file provided doesn't exists, Check path")
})

# Test if the function throws an error when the file extension is not xlsx

test_that("Error is thrown when file extension is not xlsx", {
    
    iris_df_path <- system.file("extdata", "iris.csv",
                           package = "findBiobankR")
    
    expect_error(read_multiple_sheets(iris_df_path), 
                 "The extension of the file is not an excel file")
    
    
})


# Test if the function returns a list of data frames when a valid xlsx file is provided and 
test_that("Returns a list of data frames for a valid xlsx file", {
    iris_species <- system.file("extdata", "iris_species.xlsx",
                          package = "findBiobankR")

    iris_list <- read_multiple_sheets(file_path  = iris_species )
    
  
    expect_true(is.list(iris_list))
    expect_true(all(sapply(iris_list, is.data.frame)))
    
    expect_equal(names(iris_list),c("setosa", "versicolor", "virginica"))
})




```


# any_pos_any_neg
    
```{r function-any_pos_any_neg}
#' Find any positve gven a list of column
#' 
#' Given a list of column names eg symptoms find if there are any positives
#' @param df A data.frame or data.table or tibble 
#' @param test_cols a vector of column names eg cols measuring symptoms
#' @param neg_value a value that shows  the negative outcome in test_cols
#' @param pos_value a value that measures the positive outcome in test_cols
#' @param id_cols A vector of column names in df that you would want included eg participant ID
#' @param test_type vector of length one to be appended to output name
#' @importFrom data.table setDT 
#' @return A data.table
#' 
#' @export
any_pos_any_neg <-  function(df, 
                             test_cols,
                             test_type ,
                             neg_value ="No",
                             pos_value = "Yes",
                             id_cols =c("Participant_PPID") ){
  
  
  if(isFALSE(inherits(df, "data.table"))){
    
      setDT(df)
  }
  
   if(isFALSE(length(test_type) == 1)){
    
      stop("test_type should be a vector of length one")
  }


  df[, (test_cols) := lapply(.SD, function(x) ifelse(is.na(x), "", x)), .SDcols = test_cols]

  any_neg = paste0(test_type, "_any_neg")
  any_pos = paste0(test_type, "_any_pos")
  pos_no = paste0(test_type, "_pos_no")
  neg_no = paste0(test_type, "_neg_no")
  
  row_nums = seq_len(nrow(df))
  
  cols_interest <- c(id_cols,any_neg,
                     any_pos,  pos_no,
                     neg_no)
  
  df[, (any_pos) := any(.SD== pos_value), .SDcols = test_cols , by = row_nums]
  
  df[, (any_neg) := any(.SD== neg_value), .SDcols = test_cols , by = row_nums]
  
  
  df[, (pos_no) :=sum(.SD ==pos_value), .SDcols = test_cols, by = row_nums]
  
  
  df[, (neg_no) :=sum(.SD == neg_value), .SDcols = test_cols, by = row_nums]
  
  df <- df[, .SD, .SDcols = cols_interest]
  
  df
}
```



```{r example-any_pos_any_neg}
data("tb_resp_symptoms")

respirotory_symptoms <- c("COUGH", "EXPECTORATION",
                          "HEMOPTYSIS", "CHEST_PAIN",
                          "DYSPNOE")

any_pos_any_neg(df = tb_resp_symptoms, 
                 test_cols =respirotory_symptoms ,
                 test_type = "resp_symp" ,
                 neg_value ="No",
                 pos_value = "Yes",
                 id_cols ="ID")
```


```{r tests-any_pos_any_neg}
test_that("any_pos_any_neg works", {
  expect_true(inherits(any_pos_any_neg, "function")) 
})
```


# rm_all_na_col
    
```{r function-rm_all_na_col}
#' Removes columns that de selects/deletes  columns with missing rows
#' 
#' Given a data.frame, this function will remove columns with missing values above a certain threshold.
#' 
#' @param df data.frame 
#' @param missing_perc threshold to delete columns eg delete with more than 99 % missing number should be between 0 and 100 %
#' @param na_chars character vectors representing NA's 
#' @importFrom data.table setDT
#' @return A data.table 
#' 
#' @export
rm_all_na_col <- function(df, missing_perc = 99.99, na_chars = c("", "NA", " ")){
  
  # Check if the `missing_per` argument is between 0 and 1.
  if (missing_perc < 0 | missing_perc > 100){
    stop("The `missing_per` argument must be between 0 and 1.")
  }
  
  # Check if the `na_chars` argument is a vector of strings.
  if (!is.character(na_chars) | length(na_chars) == 0){
    stop("The `na_chars` argument must be a vector of strings.")
  }
  
  setDT(df)
  # Replace missing values in the data frame with `NA`.
  nms = names(df)
  df[, (nms) := lapply(.SD, function(x) ifelse(x %in% na_chars, NA, x)), .SDcols = names(df)]
  
  # Calculate the percentage of missing values for each column.
  missing_rows_perc <- df[ , lapply(.SD, function(x)sum(is.na(x)/.N * 100)), .SDcols = nms]
                     
  missing_rows_perc <-missing_rows_perc[1,] %>% as.numeric()
  
  # Identify columns with more than `missing_per` missing values.
  nms_del <- nms[missing_rows_perc > missing_perc]
  
  # Drop the columns with more than `missing_per` missing values.
  df[, (nms_del) := NULL]
  
  return(df)
}

```
  
```{r example-rm_all_na_col}
library(data.table)

# Create a data frame with missing values.
df <- data.table(
  id = 1:10,
  name = c("John", "Jane", "", "Mary", "Mike", "", "", "Peter", "Sam", "Susan"),
  age = c(20, 21, 18, 22, 23, 19, NA, 24, 25, 26),
  height = c(170, 160, 180, 175, 185, 175, NA, 190, 195, 200),
  plasma_collected = rep(NA, 10)
)

# Remove columns with more than 99% missing values.
rm_all_na_col(df, missing_perc = 99.99)
```
  
```{r tests-rm_all_na_col}
# Test that the function correctly identifies columns with more than 99% missing values.
test_that("The function correctly identifies columns with more than 99% missing values", {
  
  library(data.table)
  df <- data.table(
  id = 1:10,
  name = c("John", "Jane", "", "Mary", "Mike", "", "", "Peter", "Sam", "Susan"),
  age = c(20, 21, 18, 22, 23, 19, NA, 24, 25, 26),
  height = c(170, 160, 180, 175, 185, 175, NA, 190, 195, 200),
  plasma_collected = rep(NA, 10)
)
 rm_all_na_col(df, missing_per = 99.99)
 expect_equal(names(df), c("id", "name", "age", "height"))
  
  # Test that the function correctly drops columns with more than 99% missing values.
  expect_false("plasma_collected" %in% names(df))
})

```
  
# read_multiple_files
    
```{r function-read_multiple_files}
#' Read multiple files from a folder
#' 
#' Read Files From excel workbook 
#' 
#' @param folder_path path to file  
#' @param ... Other parameters from read function used 
#' @param read_function The read function eg read.csv, 
#' read_excel, fread. Depends on your file types or function preference. 
#' Please note to load the library you want to use the function from
#' @param pattern A pattern to be passed to list.files function
#' @param file_names If you have a vector of file names then this could also be used instead of pattern
#' @return returns a list of data frames 
#' @importFrom data.table setDT 
#' @importFrom purrr  set_names possibly
#' @importFrom tools file_ext
#' @importFrom janitor make_clean_names
#' @return A list of data frames 
#' 
#' @export
#'
#' @examples
#' iris_species <- system.file("extdata", "iris_species.xlsx",
#'                           package = "findBiobankR")
#'
#' iris_list <- read_multiple_sheets(file_path  = iris_species ) %>% 
#'   lapply(head, 4)
#' iris_list
#' 

read_multiple_files <- function(folder_path,
                                read_function = "fread",
                                pattern = NULL,
                                file_names = NULL,
                                ...){
  
  
  if(isFALSE(dir.exists(dirname(folder_path)))) {
    
    stop("The directory provided doesn't exists, Check path")
  } 
  
  if(is.null(pattern) & is.null(file_names)){
    
    stop("Please provide a pattern or a vector of file names")
  }
  
  if(!is.null(pattern) & !is.null(file_names)){
    
    stop("Please provide  pattern or a vector of file names")
  }
  if(!is.null(pattern) & is.null(file_names)){
    
    if(length(pattern) != 1){
      
      stop("Pattern should be of length one")
    }
    
    file_names = list.files(path = folder_path, pattern = pattern )
    
    if(length(file_names) == 0){
      
      
      stop("No files found with the pattern provided. Please check ypur pattern and folder")
    }
    
    file_paths = file.path(folder_path, file_names)
    
  }else{
    
    file_paths = file.path(folder_path, file_names)
  }
  
  extesions = tools::file_ext(file_names) %>%
    unique()
  
  stopifnot("Your files are of different types" = length(extesions) == 1)
  
  files_exits <- file_paths %>%
    purrr::map_lgl(file.exists)
  
  if(!all(files_exits)){
    
    files_missing =  file_names[!files_exits] %>%
      paste0(collapse = " , ")
    warn_msg <- sprintf("The following files %s have not been found", files_missing)
    warning(warn_msg)
  }
  read_function = match.fun(read_function)
  
  
  file_names_clean <- make_clean_names(file_names)
  
  file_names_clean <- gsub(paste0("_", extesions, "$"), "",file_names_clean)
  
  possibly_read <- possibly(read_function, otherwise = NULL)
  
  list_of_files <- lapply(file_paths, function(x){
    
    possibly_read(x,  ...) %>%
      
      setDT()
    
  })%>% set_names(file_names_clean)
  
  list_of_files
  
  
}

```
  
```{r example-read_multiple_files}
library(data.table)
iris_split <- split(iris, 
                    f = iris$Species)


path_name <- tempfile(pattern = "read_multipe_files") %>%
    normalizePath(winslash = "/")

dir.create(path_name)
file_names <- paste0(names(iris_split),  ".csv")
# create file name
file_paths <- file.path(path_name, file_names)
lapply(seq_along(file_paths), function(x){
    df = iris_split[[x]]
    fwrite(df, file = file_paths[x])
})

read_multiple_files(folder_path =path_name ,
                    read_function = "fread",
                    pattern = ".csv$",
                    file_names =NULL)
#file.remove(file_name)
unlink(path_name)
```
  
```{r tests-read_multiple_files}
test_that("read_multiple_files works", {
  expect_true(inherits(read_multiple_files, "function")) 
})
```
  
```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/biobank_reports.Rmd",
               vignette_name = "biobank-reports")
```
